/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/form-data";
exports.ids = ["vendor-chunks/form-data"];
exports.modules = {

/***/ "(action-browser)/./node_modules/form-data/lib/form_data.js":
/*!*************************************************!*\
  !*** ./node_modules/form-data/lib/form_data.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var CombinedStream = __webpack_require__(/*! combined-stream */ \"(action-browser)/./node_modules/combined-stream/lib/combined_stream.js\");\nvar util = __webpack_require__(/*! util */ \"util\");\nvar path = __webpack_require__(/*! path */ \"path\");\nvar http = __webpack_require__(/*! http */ \"http\");\nvar https = __webpack_require__(/*! https */ \"https\");\nvar parseUrl = (__webpack_require__(/*! url */ \"url\").parse);\nvar fs = __webpack_require__(/*! fs */ \"fs\");\nvar Stream = (__webpack_require__(/*! stream */ \"stream\").Stream);\nvar mime = __webpack_require__(/*! mime-types */ \"(action-browser)/./node_modules/mime-types/index.js\");\nvar asynckit = __webpack_require__(/*! asynckit */ \"(action-browser)/./node_modules/asynckit/index.js\");\nvar populate = __webpack_require__(/*! ./populate.js */ \"(action-browser)/./node_modules/form-data/lib/populate.js\");\n// Public API\nmodule.exports = FormData;\n// make it a Stream\nutil.inherits(FormData, CombinedStream);\n/**\n * Create readable \"multipart/form-data\" streams.\n * Can be used to submit forms\n * and file uploads to other web applications.\n *\n * @constructor\n * @param {Object} options - Properties to be added/overriden for FormData and CombinedStream\n */ function FormData(options) {\n    if (!(this instanceof FormData)) {\n        return new FormData(options);\n    }\n    this._overheadLength = 0;\n    this._valueLength = 0;\n    this._valuesToMeasure = [];\n    CombinedStream.call(this);\n    options = options || {};\n    for(var option in options){\n        this[option] = options[option];\n    }\n}\nFormData.LINE_BREAK = \"\\r\\n\";\nFormData.DEFAULT_CONTENT_TYPE = \"application/octet-stream\";\nFormData.prototype.append = function(field, value, options) {\n    options = options || {};\n    // allow filename as single option\n    if (typeof options == \"string\") {\n        options = {\n            filename: options\n        };\n    }\n    var append = CombinedStream.prototype.append.bind(this);\n    // all that streamy business can't handle numbers\n    if (typeof value == \"number\") {\n        value = \"\" + value;\n    }\n    // https://github.com/felixge/node-form-data/issues/38\n    if (util.isArray(value)) {\n        // Please convert your array into string\n        // the way web server expects it\n        this._error(new Error(\"Arrays are not supported.\"));\n        return;\n    }\n    var header = this._multiPartHeader(field, value, options);\n    var footer = this._multiPartFooter();\n    append(header);\n    append(value);\n    append(footer);\n    // pass along options.knownLength\n    this._trackLength(header, value, options);\n};\nFormData.prototype._trackLength = function(header, value, options) {\n    var valueLength = 0;\n    // used w/ getLengthSync(), when length is known.\n    // e.g. for streaming directly from a remote server,\n    // w/ a known file a size, and not wanting to wait for\n    // incoming file to finish to get its size.\n    if (options.knownLength != null) {\n        valueLength += +options.knownLength;\n    } else if (Buffer.isBuffer(value)) {\n        valueLength = value.length;\n    } else if (typeof value === \"string\") {\n        valueLength = Buffer.byteLength(value);\n    }\n    this._valueLength += valueLength;\n    // @check why add CRLF? does this account for custom/multiple CRLFs?\n    this._overheadLength += Buffer.byteLength(header) + FormData.LINE_BREAK.length;\n    // empty or either doesn't have path or not an http response or not a stream\n    if (!value || !value.path && !(value.readable && value.hasOwnProperty(\"httpVersion\")) && !(value instanceof Stream)) {\n        return;\n    }\n    // no need to bother with the length\n    if (!options.knownLength) {\n        this._valuesToMeasure.push(value);\n    }\n};\nFormData.prototype._lengthRetriever = function(value, callback) {\n    if (value.hasOwnProperty(\"fd\")) {\n        // take read range into a account\n        // `end` = Infinity â€“> read file till the end\n        //\n        // TODO: Looks like there is bug in Node fs.createReadStream\n        // it doesn't respect `end` options without `start` options\n        // Fix it when node fixes it.\n        // https://github.com/joyent/node/issues/7819\n        if (value.end != undefined && value.end != Infinity && value.start != undefined) {\n            // when end specified\n            // no need to calculate range\n            // inclusive, starts with 0\n            callback(null, value.end + 1 - (value.start ? value.start : 0));\n        // not that fast snoopy\n        } else {\n            // still need to fetch file size from fs\n            fs.stat(value.path, function(err, stat) {\n                var fileSize;\n                if (err) {\n                    callback(err);\n                    return;\n                }\n                // update final size based on the range options\n                fileSize = stat.size - (value.start ? value.start : 0);\n                callback(null, fileSize);\n            });\n        }\n    // or http response\n    } else if (value.hasOwnProperty(\"httpVersion\")) {\n        callback(null, +value.headers[\"content-length\"]);\n    // or request stream http://github.com/mikeal/request\n    } else if (value.hasOwnProperty(\"httpModule\")) {\n        // wait till response come back\n        value.on(\"response\", function(response) {\n            value.pause();\n            callback(null, +response.headers[\"content-length\"]);\n        });\n        value.resume();\n    // something else\n    } else {\n        callback(\"Unknown stream\");\n    }\n};\nFormData.prototype._multiPartHeader = function(field, value, options) {\n    // custom header specified (as string)?\n    // it becomes responsible for boundary\n    // (e.g. to handle extra CRLFs on .NET servers)\n    if (typeof options.header == \"string\") {\n        return options.header;\n    }\n    var contentDisposition = this._getContentDisposition(value, options);\n    var contentType = this._getContentType(value, options);\n    var contents = \"\";\n    var headers = {\n        // add custom disposition as third element or keep it two elements if not\n        \"Content-Disposition\": [\n            \"form-data\",\n            'name=\"' + field + '\"'\n        ].concat(contentDisposition || []),\n        // if no content type. allow it to be empty array\n        \"Content-Type\": [].concat(contentType || [])\n    };\n    // allow custom headers.\n    if (typeof options.header == \"object\") {\n        populate(headers, options.header);\n    }\n    var header;\n    for(var prop in headers){\n        if (!headers.hasOwnProperty(prop)) continue;\n        header = headers[prop];\n        // skip nullish headers.\n        if (header == null) {\n            continue;\n        }\n        // convert all headers to arrays.\n        if (!Array.isArray(header)) {\n            header = [\n                header\n            ];\n        }\n        // add non-empty headers.\n        if (header.length) {\n            contents += prop + \": \" + header.join(\"; \") + FormData.LINE_BREAK;\n        }\n    }\n    return \"--\" + this.getBoundary() + FormData.LINE_BREAK + contents + FormData.LINE_BREAK;\n};\nFormData.prototype._getContentDisposition = function(value, options) {\n    var filename, contentDisposition;\n    if (typeof options.filepath === \"string\") {\n        // custom filepath for relative paths\n        filename = path.normalize(options.filepath).replace(/\\\\/g, \"/\");\n    } else if (options.filename || value.name || value.path) {\n        // custom filename take precedence\n        // formidable and the browser add a name property\n        // fs- and request- streams have path property\n        filename = path.basename(options.filename || value.name || value.path);\n    } else if (value.readable && value.hasOwnProperty(\"httpVersion\")) {\n        // or try http response\n        filename = path.basename(value.client._httpMessage.path || \"\");\n    }\n    if (filename) {\n        contentDisposition = 'filename=\"' + filename + '\"';\n    }\n    return contentDisposition;\n};\nFormData.prototype._getContentType = function(value, options) {\n    // use custom content-type above all\n    var contentType = options.contentType;\n    // or try `name` from formidable, browser\n    if (!contentType && value.name) {\n        contentType = mime.lookup(value.name);\n    }\n    // or try `path` from fs-, request- streams\n    if (!contentType && value.path) {\n        contentType = mime.lookup(value.path);\n    }\n    // or if it's http-reponse\n    if (!contentType && value.readable && value.hasOwnProperty(\"httpVersion\")) {\n        contentType = value.headers[\"content-type\"];\n    }\n    // or guess it from the filepath or filename\n    if (!contentType && (options.filepath || options.filename)) {\n        contentType = mime.lookup(options.filepath || options.filename);\n    }\n    // fallback to the default content type if `value` is not simple value\n    if (!contentType && typeof value == \"object\") {\n        contentType = FormData.DEFAULT_CONTENT_TYPE;\n    }\n    return contentType;\n};\nFormData.prototype._multiPartFooter = function() {\n    return (function(next) {\n        var footer = FormData.LINE_BREAK;\n        var lastPart = this._streams.length === 0;\n        if (lastPart) {\n            footer += this._lastBoundary();\n        }\n        next(footer);\n    }).bind(this);\n};\nFormData.prototype._lastBoundary = function() {\n    return \"--\" + this.getBoundary() + \"--\" + FormData.LINE_BREAK;\n};\nFormData.prototype.getHeaders = function(userHeaders) {\n    var header;\n    var formHeaders = {\n        \"content-type\": \"multipart/form-data; boundary=\" + this.getBoundary()\n    };\n    for(header in userHeaders){\n        if (userHeaders.hasOwnProperty(header)) {\n            formHeaders[header.toLowerCase()] = userHeaders[header];\n        }\n    }\n    return formHeaders;\n};\nFormData.prototype.setBoundary = function(boundary) {\n    this._boundary = boundary;\n};\nFormData.prototype.getBoundary = function() {\n    if (!this._boundary) {\n        this._generateBoundary();\n    }\n    return this._boundary;\n};\nFormData.prototype.getBuffer = function() {\n    var dataBuffer = new Buffer.alloc(0);\n    var boundary = this.getBoundary();\n    // Create the form content. Add Line breaks to the end of data.\n    for(var i = 0, len = this._streams.length; i < len; i++){\n        if (typeof this._streams[i] !== \"function\") {\n            // Add content to the buffer.\n            if (Buffer.isBuffer(this._streams[i])) {\n                dataBuffer = Buffer.concat([\n                    dataBuffer,\n                    this._streams[i]\n                ]);\n            } else {\n                dataBuffer = Buffer.concat([\n                    dataBuffer,\n                    Buffer.from(this._streams[i])\n                ]);\n            }\n            // Add break after content.\n            if (typeof this._streams[i] !== \"string\" || this._streams[i].substring(2, boundary.length + 2) !== boundary) {\n                dataBuffer = Buffer.concat([\n                    dataBuffer,\n                    Buffer.from(FormData.LINE_BREAK)\n                ]);\n            }\n        }\n    }\n    // Add the footer and return the Buffer object.\n    return Buffer.concat([\n        dataBuffer,\n        Buffer.from(this._lastBoundary())\n    ]);\n};\nFormData.prototype._generateBoundary = function() {\n    // This generates a 50 character boundary similar to those used by Firefox.\n    // They are optimized for boyer-moore parsing.\n    var boundary = \"--------------------------\";\n    for(var i = 0; i < 24; i++){\n        boundary += Math.floor(Math.random() * 10).toString(16);\n    }\n    this._boundary = boundary;\n};\n// Note: getLengthSync DOESN'T calculate streams length\n// As workaround one can calculate file size manually\n// and add it as knownLength option\nFormData.prototype.getLengthSync = function() {\n    var knownLength = this._overheadLength + this._valueLength;\n    // Don't get confused, there are 3 \"internal\" streams for each keyval pair\n    // so it basically checks if there is any value added to the form\n    if (this._streams.length) {\n        knownLength += this._lastBoundary().length;\n    }\n    // https://github.com/form-data/form-data/issues/40\n    if (!this.hasKnownLength()) {\n        // Some async length retrievers are present\n        // therefore synchronous length calculation is false.\n        // Please use getLength(callback) to get proper length\n        this._error(new Error(\"Cannot calculate proper length in synchronous way.\"));\n    }\n    return knownLength;\n};\n// Public API to check if length of added values is known\n// https://github.com/form-data/form-data/issues/196\n// https://github.com/form-data/form-data/issues/262\nFormData.prototype.hasKnownLength = function() {\n    var hasKnownLength = true;\n    if (this._valuesToMeasure.length) {\n        hasKnownLength = false;\n    }\n    return hasKnownLength;\n};\nFormData.prototype.getLength = function(cb) {\n    var knownLength = this._overheadLength + this._valueLength;\n    if (this._streams.length) {\n        knownLength += this._lastBoundary().length;\n    }\n    if (!this._valuesToMeasure.length) {\n        process.nextTick(cb.bind(this, null, knownLength));\n        return;\n    }\n    asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, function(err, values) {\n        if (err) {\n            cb(err);\n            return;\n        }\n        values.forEach(function(length) {\n            knownLength += length;\n        });\n        cb(null, knownLength);\n    });\n};\nFormData.prototype.submit = function(params, cb) {\n    var request, options, defaults = {\n        method: \"post\"\n    };\n    // parse provided url if it's string\n    // or treat it as options object\n    if (typeof params == \"string\") {\n        params = parseUrl(params);\n        options = populate({\n            port: params.port,\n            path: params.pathname,\n            host: params.hostname,\n            protocol: params.protocol\n        }, defaults);\n    // use custom params\n    } else {\n        options = populate(params, defaults);\n        // if no port provided use default one\n        if (!options.port) {\n            options.port = options.protocol == \"https:\" ? 443 : 80;\n        }\n    }\n    // put that good code in getHeaders to some use\n    options.headers = this.getHeaders(params.headers);\n    // https if specified, fallback to http in any other case\n    if (options.protocol == \"https:\") {\n        request = https.request(options);\n    } else {\n        request = http.request(options);\n    }\n    // get content length and fire away\n    this.getLength((function(err, length) {\n        if (err && err !== \"Unknown stream\") {\n            this._error(err);\n            return;\n        }\n        // add content length\n        if (length) {\n            request.setHeader(\"Content-Length\", length);\n        }\n        this.pipe(request);\n        if (cb) {\n            var onResponse;\n            var callback = function(error, responce) {\n                request.removeListener(\"error\", callback);\n                request.removeListener(\"response\", onResponse);\n                return cb.call(this, error, responce);\n            };\n            onResponse = callback.bind(this, null);\n            request.on(\"error\", callback);\n            request.on(\"response\", onResponse);\n        }\n    }).bind(this));\n    return request;\n};\nFormData.prototype._error = function(err) {\n    if (!this.error) {\n        this.error = err;\n        this.pause();\n        this.emit(\"error\", err);\n    }\n};\nFormData.prototype.toString = function() {\n    return \"[object FormData]\";\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9mb3JtLWRhdGEvbGliL2Zvcm1fZGF0YS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxJQUFJQSxpQkFBaUJDLG1CQUFPQSxDQUFDO0FBQzdCLElBQUlDLE9BQU9ELG1CQUFPQSxDQUFDO0FBQ25CLElBQUlFLE9BQU9GLG1CQUFPQSxDQUFDO0FBQ25CLElBQUlHLE9BQU9ILG1CQUFPQSxDQUFDO0FBQ25CLElBQUlJLFFBQVFKLG1CQUFPQSxDQUFDO0FBQ3BCLElBQUlLLFdBQVdMLDZDQUFvQjtBQUNuQyxJQUFJTyxLQUFLUCxtQkFBT0EsQ0FBQztBQUNqQixJQUFJUSxTQUFTUixvREFBd0I7QUFDckMsSUFBSVMsT0FBT1QsbUJBQU9BLENBQUM7QUFDbkIsSUFBSVUsV0FBV1YsbUJBQU9BLENBQUM7QUFDdkIsSUFBSVcsV0FBV1gsbUJBQU9BLENBQUM7QUFFdkIsYUFBYTtBQUNiWSxPQUFPQyxPQUFPLEdBQUdDO0FBRWpCLG1CQUFtQjtBQUNuQmIsS0FBS2MsUUFBUSxDQUFDRCxVQUFVZjtBQUV4Qjs7Ozs7OztDQU9DLEdBQ0QsU0FBU2UsU0FBU0UsT0FBTztJQUN2QixJQUFJLENBQUUsS0FBSSxZQUFZRixRQUFPLEdBQUk7UUFDL0IsT0FBTyxJQUFJQSxTQUFTRTtJQUN0QjtJQUVBLElBQUksQ0FBQ0MsZUFBZSxHQUFHO0lBQ3ZCLElBQUksQ0FBQ0MsWUFBWSxHQUFHO0lBQ3BCLElBQUksQ0FBQ0MsZ0JBQWdCLEdBQUcsRUFBRTtJQUUxQnBCLGVBQWVxQixJQUFJLENBQUMsSUFBSTtJQUV4QkosVUFBVUEsV0FBVyxDQUFDO0lBQ3RCLElBQUssSUFBSUssVUFBVUwsUUFBUztRQUMxQixJQUFJLENBQUNLLE9BQU8sR0FBR0wsT0FBTyxDQUFDSyxPQUFPO0lBQ2hDO0FBQ0Y7QUFFQVAsU0FBU1EsVUFBVSxHQUFHO0FBQ3RCUixTQUFTUyxvQkFBb0IsR0FBRztBQUVoQ1QsU0FBU1UsU0FBUyxDQUFDQyxNQUFNLEdBQUcs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QUFFQXhDLFNBQVNVLFNBQVMsQ0FBQzhFLFFBQVEsR0FBRztJQUM1QixPQUFPO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92aGQtdHYvLi9ub2RlX21vZHVsZXMvZm9ybS1kYXRhL2xpYi9mb3JtX2RhdGEuanM/MmIwZCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgQ29tYmluZWRTdHJlYW0gPSByZXF1aXJlKCdjb21iaW5lZC1zdHJlYW0nKTtcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xudmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG52YXIgaHR0cCA9IHJlcXVpcmUoJ2h0dHAnKTtcbnZhciBodHRwcyA9IHJlcXVpcmUoJ2h0dHBzJyk7XG52YXIgcGFyc2VVcmwgPSByZXF1aXJlKCd1cmwnKS5wYXJzZTtcbnZhciBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG52YXIgU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJykuU3RyZWFtO1xudmFyIG1pbWUgPSByZXF1aXJlKCdtaW1lLXR5cGVzJyk7XG52YXIgYXN5bmNraXQgPSByZXF1aXJlKCdhc3luY2tpdCcpO1xudmFyIHBvcHVsYXRlID0gcmVxdWlyZSgnLi9wb3B1bGF0ZS5qcycpO1xuXG4vLyBQdWJsaWMgQVBJXG5tb2R1bGUuZXhwb3J0cyA9IEZvcm1EYXRhO1xuXG4vLyBtYWtlIGl0IGEgU3RyZWFtXG51dGlsLmluaGVyaXRzKEZvcm1EYXRhLCBDb21iaW5lZFN0cmVhbSk7XG5cbi8qKlxuICogQ3JlYXRlIHJlYWRhYmxlIFwibXVsdGlwYXJ0L2Zvcm0tZGF0YVwiIHN0cmVhbXMuXG4gKiBDYW4gYmUgdXNlZCB0byBzdWJtaXQgZm9ybXNcbiAqIGFuZCBmaWxlIHVwbG9hZHMgdG8gb3RoZXIgd2ViIGFwcGxpY2F0aW9ucy5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gUHJvcGVydGllcyB0byBiZSBhZGRlZC9vdmVycmlkZW4gZm9yIEZvcm1EYXRhIGFuZCBDb21iaW5lZFN0cmVhbVxuICovXG5mdW5jdGlvbiBGb3JtRGF0YShvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBGb3JtRGF0YSkpIHtcbiAgICByZXR1cm4gbmV3IEZvcm1EYXRhKG9wdGlvbnMpO1xuICB9XG5cbiAgdGhpcy5fb3ZlcmhlYWRMZW5ndGggPSAwO1xuICB0aGlzLl92YWx1ZUxlbmd0aCA9IDA7XG4gIHRoaXMuX3ZhbHVlc1RvTWVhc3VyZSA9IFtdO1xuXG4gIENvbWJpbmVkU3RyZWFtLmNhbGwodGhpcyk7XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGZvciAodmFyIG9wdGlvbiBpbiBvcHRpb25zKSB7XG4gICAgdGhpc1tvcHRpb25dID0gb3B0aW9uc1tvcHRpb25dO1xuICB9XG59XG5cbkZvcm1EYXRhLkxJTkVfQlJFQUsgPSAnXFxyXFxuJztcbkZvcm1EYXRhLkRFRkFVTFRfQ09OVEVOVF9UWVBFID0gJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbSc7XG5cbkZvcm1EYXRhLnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbihmaWVsZCwgdmFsdWUsIG9wdGlvbnMpIHtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyBhbGxvdyBmaWxlbmFtZSBhcyBzaW5nbGUgb3B0aW9uXG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PSAnc3RyaW5nJykge1xuICAgIG9wdGlvbnMgPSB7ZmlsZW5hbWU6IG9wdGlvbnN9O1xuICB9XG5cbiAgdmFyIGFwcGVuZCA9IENvbWJpbmVkU3RyZWFtLnByb3RvdHlwZS5hcHBlbmQuYmluZCh0aGlzKTtcblxuICAvLyBhbGwgdGhhdCBzdHJlYW15IGJ1c2luZXNzIGNhbid0IGhhbmRsZSBudW1iZXJzXG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicpIHtcbiAgICB2YWx1ZSA9ICcnICsgdmFsdWU7XG4gIH1cblxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmVsaXhnZS9ub2RlLWZvcm0tZGF0YS9pc3N1ZXMvMzhcbiAgaWYgKHV0aWwuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAvLyBQbGVhc2UgY29udmVydCB5b3VyIGFycmF5IGludG8gc3RyaW5nXG4gICAgLy8gdGhlIHdheSB3ZWIgc2VydmVyIGV4cGVjdHMgaXRcbiAgICB0aGlzLl9lcnJvcihuZXcgRXJyb3IoJ0FycmF5cyBhcmUgbm90IHN1cHBvcnRlZC4nKSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGhlYWRlciA9IHRoaXMuX211bHRpUGFydEhlYWRlcihmaWVsZCwgdmFsdWUsIG9wdGlvbnMpO1xuICB2YXIgZm9vdGVyID0gdGhpcy5fbXVsdGlQYXJ0Rm9vdGVyKCk7XG5cbiAgYXBwZW5kKGhlYWRlcik7XG4gIGFwcGVuZCh2YWx1ZSk7XG4gIGFwcGVuZChmb290ZXIpO1xuXG4gIC8vIHBhc3MgYWxvbmcgb3B0aW9ucy5rbm93bkxlbmd0aFxuICB0aGlzLl90cmFja0xlbmd0aChoZWFkZXIsIHZhbHVlLCBvcHRpb25zKTtcbn07XG5cbkZvcm1EYXRhLnByb3RvdHlwZS5fdHJhY2tMZW5ndGggPSBmdW5jdGlvbihoZWFkZXIsIHZhbHVlLCBvcHRpb25zKSB7XG4gIHZhciB2YWx1ZUxlbmd0aCA9IDA7XG5cbiAgLy8gdXNlZCB3LyBnZXRMZW5ndGhTeW5jKCksIHdoZW4gbGVuZ3RoIGlzIGtub3duLlxuICAvLyBlLmcuIGZvciBzdHJlYW1pbmcgZGlyZWN0bHkgZnJvbSBhIHJlbW90ZSBzZXJ2ZXIsXG4gIC8vIHcvIGEga25vd24gZmlsZSBhIHNpemUsIGFuZCBub3Qgd2FudGluZyB0byB3YWl0IGZvclxuICAvLyBpbmNvbWluZyBmaWxlIHRvIGZpbmlzaCB0byBnZXQgaXRzIHNpemUuXG4gIGlmIChvcHRpb25zLmtub3duTGVuZ3RoICE9IG51bGwpIHtcbiAgICB2YWx1ZUxlbmd0aCArPSArb3B0aW9ucy5rbm93bkxlbmd0aDtcbiAgfSBlbHNlIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsdWUpKSB7XG4gICAgdmFsdWVMZW5ndGggPSB2YWx1ZS5sZW5ndGg7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHZhbHVlTGVuZ3RoID0gQnVmZmVyLmJ5dGVMZW5ndGgodmFsdWUpO1xuICB9XG5cbiAgdGhpcy5fdmFsdWVMZW5ndGggKz0gdmFsdWVMZW5ndGg7XG5cbiAgLy8gQGNoZWNrIHdoeSBhZGQgQ1JMRj8gZG9lcyB0aGlzIGFjY291bnQgZm9yIGN1c3RvbS9tdWx0aXBsZSBDUkxGcz9cbiAgdGhpcy5fb3ZlcmhlYWRMZW5ndGggKz1cbiAgICBCdWZmZXIuYnl0ZUxlbmd0aChoZWFkZXIpICtcbiAgICBGb3JtRGF0YS5MSU5FX0JSRUFLLmxlbmd0aDtcblxuICAvLyBlbXB0eSBvciBlaXRoZXIgZG9lc24ndCBoYXZlIHBhdGggb3Igbm90IGFuIGh0dHAgcmVzcG9uc2Ugb3Igbm90IGEgc3RyZWFtXG4gIGlmICghdmFsdWUgfHwgKCAhdmFsdWUucGF0aCAmJiAhKHZhbHVlLnJlYWRhYmxlICYmIHZhbHVlLmhhc093blByb3BlcnR5KCdodHRwVmVyc2lvbicpKSAmJiAhKHZhbHVlIGluc3RhbmNlb2YgU3RyZWFtKSkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBubyBuZWVkIHRvIGJvdGhlciB3aXRoIHRoZSBsZW5ndGhcbiAgaWYgKCFvcHRpb25zLmtub3duTGVuZ3RoKSB7XG4gICAgdGhpcy5fdmFsdWVzVG9NZWFzdXJlLnB1c2godmFsdWUpO1xuICB9XG59O1xuXG5Gb3JtRGF0YS5wcm90b3R5cGUuX2xlbmd0aFJldHJpZXZlciA9IGZ1bmN0aW9uKHZhbHVlLCBjYWxsYmFjaykge1xuXG4gIGlmICh2YWx1ZS5oYXNPd25Qcm9wZXJ0eSgnZmQnKSkge1xuXG4gICAgLy8gdGFrZSByZWFkIHJhbmdlIGludG8gYSBhY2NvdW50XG4gICAgLy8gYGVuZGAgPSBJbmZpbml0eSDigJM+IHJlYWQgZmlsZSB0aWxsIHRoZSBlbmRcbiAgICAvL1xuICAgIC8vIFRPRE86IExvb2tzIGxpa2UgdGhlcmUgaXMgYnVnIGluIE5vZGUgZnMuY3JlYXRlUmVhZFN0cmVhbVxuICAgIC8vIGl0IGRvZXNuJ3QgcmVzcGVjdCBgZW5kYCBvcHRpb25zIHdpdGhvdXQgYHN0YXJ0YCBvcHRpb25zXG4gICAgLy8gRml4IGl0IHdoZW4gbm9kZSBmaXhlcyBpdC5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vam95ZW50L25vZGUvaXNzdWVzLzc4MTlcbiAgICBpZiAodmFsdWUuZW5kICE9IHVuZGVmaW5lZCAmJiB2YWx1ZS5lbmQgIT0gSW5maW5pdHkgJiYgdmFsdWUuc3RhcnQgIT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgIC8vIHdoZW4gZW5kIHNwZWNpZmllZFxuICAgICAgLy8gbm8gbmVlZCB0byBjYWxjdWxhdGUgcmFuZ2VcbiAgICAgIC8vIGluY2x1c2l2ZSwgc3RhcnRzIHdpdGggMFxuICAgICAgY2FsbGJhY2sobnVsbCwgdmFsdWUuZW5kICsgMSAtICh2YWx1ZS5zdGFydCA/IHZhbHVlLnN0YXJ0IDogMCkpO1xuXG4gICAgLy8gbm90IHRoYXQgZmFzdCBzbm9vcHlcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gc3RpbGwgbmVlZCB0byBmZXRjaCBmaWxlIHNpemUgZnJvbSBmc1xuICAgICAgZnMuc3RhdCh2YWx1ZS5wYXRoLCBmdW5jdGlvbihlcnIsIHN0YXQpIHtcblxuICAgICAgICB2YXIgZmlsZVNpemU7XG5cbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdXBkYXRlIGZpbmFsIHNpemUgYmFzZWQgb24gdGhlIHJhbmdlIG9wdGlvbnNcbiAgICAgICAgZmlsZVNpemUgPSBzdGF0LnNpemUgLSAodmFsdWUuc3RhcnQgPyB2YWx1ZS5zdGFydCA6IDApO1xuICAgICAgICBjYWxsYmFjayhudWxsLCBmaWxlU2l6ZSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgLy8gb3IgaHR0cCByZXNwb25zZVxuICB9IGVsc2UgaWYgKHZhbHVlLmhhc093blByb3BlcnR5KCdodHRwVmVyc2lvbicpKSB7XG4gICAgY2FsbGJhY2sobnVsbCwgK3ZhbHVlLmhlYWRlcnNbJ2NvbnRlbnQtbGVuZ3RoJ10pO1xuXG4gIC8vIG9yIHJlcXVlc3Qgc3RyZWFtIGh0dHA6Ly9naXRodWIuY29tL21pa2VhbC9yZXF1ZXN0XG4gIH0gZWxzZSBpZiAodmFsdWUuaGFzT3duUHJvcGVydHkoJ2h0dHBNb2R1bGUnKSkge1xuICAgIC8vIHdhaXQgdGlsbCByZXNwb25zZSBjb21lIGJhY2tcbiAgICB2YWx1ZS5vbigncmVzcG9uc2UnLCBmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgdmFsdWUucGF1c2UoKTtcbiAgICAgIGNhbGxiYWNrKG51bGwsICtyZXNwb25zZS5oZWFkZXJzWydjb250ZW50LWxlbmd0aCddKTtcbiAgICB9KTtcbiAgICB2YWx1ZS5yZXN1bWUoKTtcblxuICAvLyBzb21ldGhpbmcgZWxzZVxuICB9IGVsc2Uge1xuICAgIGNhbGxiYWNrKCdVbmtub3duIHN0cmVhbScpO1xuICB9XG59O1xuXG5Gb3JtRGF0YS5wcm90b3R5cGUuX211bHRpUGFydEhlYWRlciA9IGZ1bmN0aW9uKGZpZWxkLCB2YWx1ZSwgb3B0aW9ucykge1xuICAvLyBjdXN0b20gaGVhZGVyIHNwZWNpZmllZCAoYXMgc3RyaW5nKT9cbiAgLy8gaXQgYmVjb21lcyByZXNwb25zaWJsZSBmb3IgYm91bmRhcnlcbiAgLy8gKGUuZy4gdG8gaGFuZGxlIGV4dHJhIENSTEZzIG9uIC5ORVQgc2VydmVycylcbiAgaWYgKHR5cGVvZiBvcHRpb25zLmhlYWRlciA9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBvcHRpb25zLmhlYWRlcjtcbiAgfVxuXG4gIHZhciBjb250ZW50RGlzcG9zaXRpb24gPSB0aGlzLl9nZXRDb250ZW50RGlzcG9zaXRpb24odmFsdWUsIG9wdGlvbnMpO1xuICB2YXIgY29udGVudFR5cGUgPSB0aGlzLl9nZXRDb250ZW50VHlwZSh2YWx1ZSwgb3B0aW9ucyk7XG5cbiAgdmFyIGNvbnRlbnRzID0gJyc7XG4gIHZhciBoZWFkZXJzICA9IHtcbiAgICAvLyBhZGQgY3VzdG9tIGRpc3Bvc2l0aW9uIGFzIHRoaXJkIGVsZW1lbnQgb3Iga2VlcCBpdCB0d28gZWxlbWVudHMgaWYgbm90XG4gICAgJ0NvbnRlbnQtRGlzcG9zaXRpb24nOiBbJ2Zvcm0tZGF0YScsICduYW1lPVwiJyArIGZpZWxkICsgJ1wiJ10uY29uY2F0KGNvbnRlbnREaXNwb3NpdGlvbiB8fCBbXSksXG4gICAgLy8gaWYgbm8gY29udGVudCB0eXBlLiBhbGxvdyBpdCB0byBiZSBlbXB0eSBhcnJheVxuICAgICdDb250ZW50LVR5cGUnOiBbXS5jb25jYXQoY29udGVudFR5cGUgfHwgW10pXG4gIH07XG5cbiAgLy8gYWxsb3cgY3VzdG9tIGhlYWRlcnMuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5oZWFkZXIgPT0gJ29iamVjdCcpIHtcbiAgICBwb3B1bGF0ZShoZWFkZXJzLCBvcHRpb25zLmhlYWRlcik7XG4gIH1cblxuICB2YXIgaGVhZGVyO1xuICBmb3IgKHZhciBwcm9wIGluIGhlYWRlcnMpIHtcbiAgICBpZiAoIWhlYWRlcnMuaGFzT3duUHJvcGVydHkocHJvcCkpIGNvbnRpbnVlO1xuICAgIGhlYWRlciA9IGhlYWRlcnNbcHJvcF07XG5cbiAgICAvLyBza2lwIG51bGxpc2ggaGVhZGVycy5cbiAgICBpZiAoaGVhZGVyID09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGNvbnZlcnQgYWxsIGhlYWRlcnMgdG8gYXJyYXlzLlxuICAgIGlmICghQXJyYXkuaXNBcnJheShoZWFkZXIpKSB7XG4gICAgICBoZWFkZXIgPSBbaGVhZGVyXTtcbiAgICB9XG5cbiAgICAvLyBhZGQgbm9uLWVtcHR5IGhlYWRlcnMuXG4gICAgaWYgKGhlYWRlci5sZW5ndGgpIHtcbiAgICAgIGNvbnRlbnRzICs9IHByb3AgKyAnOiAnICsgaGVhZGVyLmpvaW4oJzsgJykgKyBGb3JtRGF0YS5MSU5FX0JSRUFLO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAnLS0nICsgdGhpcy5nZXRCb3VuZGFyeSgpICsgRm9ybURhdGEuTElORV9CUkVBSyArIGNvbnRlbnRzICsgRm9ybURhdGEuTElORV9CUkVBSztcbn07XG5cbkZvcm1EYXRhLnByb3RvdHlwZS5fZ2V0Q29udGVudERpc3Bvc2l0aW9uID0gZnVuY3Rpb24odmFsdWUsIG9wdGlvbnMpIHtcblxuICB2YXIgZmlsZW5hbWVcbiAgICAsIGNvbnRlbnREaXNwb3NpdGlvblxuICAgIDtcblxuICBpZiAodHlwZW9mIG9wdGlvbnMuZmlsZXBhdGggPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gY3VzdG9tIGZpbGVwYXRoIGZvciByZWxhdGl2ZSBwYXRoc1xuICAgIGZpbGVuYW1lID0gcGF0aC5ub3JtYWxpemUob3B0aW9ucy5maWxlcGF0aCkucmVwbGFjZSgvXFxcXC9nLCAnLycpO1xuICB9IGVsc2UgaWYgKG9wdGlvbnMuZmlsZW5hbWUgfHwgdmFsdWUubmFtZSB8fCB2YWx1ZS5wYXRoKSB7XG4gICAgLy8gY3VzdG9tIGZpbGVuYW1lIHRha2UgcHJlY2VkZW5jZVxuICAgIC8vIGZvcm1pZGFibGUgYW5kIHRoZSBicm93c2VyIGFkZCBhIG5hbWUgcHJvcGVydHlcbiAgICAvLyBmcy0gYW5kIHJlcXVlc3QtIHN0cmVhbXMgaGF2ZSBwYXRoIHByb3BlcnR5XG4gICAgZmlsZW5hbWUgPSBwYXRoLmJhc2VuYW1lKG9wdGlvbnMuZmlsZW5hbWUgfHwgdmFsdWUubmFtZSB8fCB2YWx1ZS5wYXRoKTtcbiAgfSBlbHNlIGlmICh2YWx1ZS5yZWFkYWJsZSAmJiB2YWx1ZS5oYXNPd25Qcm9wZXJ0eSgnaHR0cFZlcnNpb24nKSkge1xuICAgIC8vIG9yIHRyeSBodHRwIHJlc3BvbnNlXG4gICAgZmlsZW5hbWUgPSBwYXRoLmJhc2VuYW1lKHZhbHVlLmNsaWVudC5faHR0cE1lc3NhZ2UucGF0aCB8fCAnJyk7XG4gIH1cblxuICBpZiAoZmlsZW5hbWUpIHtcbiAgICBjb250ZW50RGlzcG9zaXRpb24gPSAnZmlsZW5hbWU9XCInICsgZmlsZW5hbWUgKyAnXCInO1xuICB9XG5cbiAgcmV0dXJuIGNvbnRlbnREaXNwb3NpdGlvbjtcbn07XG5cbkZvcm1EYXRhLnByb3RvdHlwZS5fZ2V0Q29udGVudFR5cGUgPSBmdW5jdGlvbih2YWx1ZSwgb3B0aW9ucykge1xuXG4gIC8vIHVzZSBjdXN0b20gY29udGVudC10eXBlIGFib3ZlIGFsbFxuICB2YXIgY29udGVudFR5cGUgPSBvcHRpb25zLmNvbnRlbnRUeXBlO1xuXG4gIC8vIG9yIHRyeSBgbmFtZWAgZnJvbSBmb3JtaWRhYmxlLCBicm93c2VyXG4gIGlmICghY29udGVudFR5cGUgJiYgdmFsdWUubmFtZSkge1xuICAgIGNvbnRlbnRUeXBlID0gbWltZS5sb29rdXAodmFsdWUubmFtZSk7XG4gIH1cblxuICAvLyBvciB0cnkgYHBhdGhgIGZyb20gZnMtLCByZXF1ZXN0LSBzdHJlYW1zXG4gIGlmICghY29udGVudFR5cGUgJiYgdmFsdWUucGF0aCkge1xuICAgIGNvbnRlbnRUeXBlID0gbWltZS5sb29rdXAodmFsdWUucGF0aCk7XG4gIH1cblxuICAvLyBvciBpZiBpdCdzIGh0dHAtcmVwb25zZVxuICBpZiAoIWNvbnRlbnRUeXBlICYmIHZhbHVlLnJlYWRhYmxlICYmIHZhbHVlLmhhc093blByb3BlcnR5KCdodHRwVmVyc2lvbicpKSB7XG4gICAgY29udGVudFR5cGUgPSB2YWx1ZS5oZWFkZXJzWydjb250ZW50LXR5cGUnXTtcbiAgfVxuXG4gIC8vIG9yIGd1ZXNzIGl0IGZyb20gdGhlIGZpbGVwYXRoIG9yIGZpbGVuYW1lXG4gIGlmICghY29udGVudFR5cGUgJiYgKG9wdGlvbnMuZmlsZXBhdGggfHwgb3B0aW9ucy5maWxlbmFtZSkpIHtcbiAgICBjb250ZW50VHlwZSA9IG1pbWUubG9va3VwKG9wdGlvbnMuZmlsZXBhdGggfHwgb3B0aW9ucy5maWxlbmFtZSk7XG4gIH1cblxuICAvLyBmYWxsYmFjayB0byB0aGUgZGVmYXVsdCBjb250ZW50IHR5cGUgaWYgYHZhbHVlYCBpcyBub3Qgc2ltcGxlIHZhbHVlXG4gIGlmICghY29udGVudFR5cGUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnKSB7XG4gICAgY29udGVudFR5cGUgPSBGb3JtRGF0YS5ERUZBVUxUX0NPTlRFTlRfVFlQRTtcbiAgfVxuXG4gIHJldHVybiBjb250ZW50VHlwZTtcbn07XG5cbkZvcm1EYXRhLnByb3RvdHlwZS5fbXVsdGlQYXJ0Rm9vdGVyID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBmdW5jdGlvbihuZXh0KSB7XG4gICAgdmFyIGZvb3RlciA9IEZvcm1EYXRhLkxJTkVfQlJFQUs7XG5cbiAgICB2YXIgbGFzdFBhcnQgPSAodGhpcy5fc3RyZWFtcy5sZW5ndGggPT09IDApO1xuICAgIGlmIChsYXN0UGFydCkge1xuICAgICAgZm9vdGVyICs9IHRoaXMuX2xhc3RCb3VuZGFyeSgpO1xuICAgIH1cblxuICAgIG5leHQoZm9vdGVyKTtcbiAgfS5iaW5kKHRoaXMpO1xufTtcblxuRm9ybURhdGEucHJvdG90eXBlLl9sYXN0Qm91bmRhcnkgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICctLScgKyB0aGlzLmdldEJvdW5kYXJ5KCkgKyAnLS0nICsgRm9ybURhdGEuTElORV9CUkVBSztcbn07XG5cbkZvcm1EYXRhLnByb3RvdHlwZS5nZXRIZWFkZXJzID0gZnVuY3Rpb24odXNlckhlYWRlcnMpIHtcbiAgdmFyIGhlYWRlcjtcbiAgdmFyIGZvcm1IZWFkZXJzID0ge1xuICAgICdjb250ZW50LXR5cGUnOiAnbXVsdGlwYXJ0L2Zvcm0tZGF0YTsgYm91bmRhcnk9JyArIHRoaXMuZ2V0Qm91bmRhcnkoKVxuICB9O1xuXG4gIGZvciAoaGVhZGVyIGluIHVzZXJIZWFkZXJzKSB7XG4gICAgaWYgKHVzZXJIZWFkZXJzLmhhc093blByb3BlcnR5KGhlYWRlcikpIHtcbiAgICAgIGZvcm1IZWFkZXJzW2hlYWRlci50b0xvd2VyQ2FzZSgpXSA9IHVzZXJIZWFkZXJzW2hlYWRlcl07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZvcm1IZWFkZXJzO1xufTtcblxuRm9ybURhdGEucHJvdG90eXBlLnNldEJvdW5kYXJ5ID0gZnVuY3Rpb24oYm91bmRhcnkpIHtcbiAgdGhpcy5fYm91bmRhcnkgPSBib3VuZGFyeTtcbn07XG5cbkZvcm1EYXRhLnByb3RvdHlwZS5nZXRCb3VuZGFyeSA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMuX2JvdW5kYXJ5KSB7XG4gICAgdGhpcy5fZ2VuZXJhdGVCb3VuZGFyeSgpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuX2JvdW5kYXJ5O1xufTtcblxuRm9ybURhdGEucHJvdG90eXBlLmdldEJ1ZmZlciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZGF0YUJ1ZmZlciA9IG5ldyBCdWZmZXIuYWxsb2MoIDAgKTtcbiAgdmFyIGJvdW5kYXJ5ID0gdGhpcy5nZXRCb3VuZGFyeSgpO1xuXG4gIC8vIENyZWF0ZSB0aGUgZm9ybSBjb250ZW50LiBBZGQgTGluZSBicmVha3MgdG8gdGhlIGVuZCBvZiBkYXRhLlxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5fc3RyZWFtcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmICh0eXBlb2YgdGhpcy5fc3RyZWFtc1tpXSAhPT0gJ2Z1bmN0aW9uJykge1xuXG4gICAgICAvLyBBZGQgY29udGVudCB0byB0aGUgYnVmZmVyLlxuICAgICAgaWYoQnVmZmVyLmlzQnVmZmVyKHRoaXMuX3N0cmVhbXNbaV0pKSB7XG4gICAgICAgIGRhdGFCdWZmZXIgPSBCdWZmZXIuY29uY2F0KCBbZGF0YUJ1ZmZlciwgdGhpcy5fc3RyZWFtc1tpXV0pO1xuICAgICAgfWVsc2Uge1xuICAgICAgICBkYXRhQnVmZmVyID0gQnVmZmVyLmNvbmNhdCggW2RhdGFCdWZmZXIsIEJ1ZmZlci5mcm9tKHRoaXMuX3N0cmVhbXNbaV0pXSk7XG4gICAgICB9XG5cbiAgICAgIC8vIEFkZCBicmVhayBhZnRlciBjb250ZW50LlxuICAgICAgaWYgKHR5cGVvZiB0aGlzLl9zdHJlYW1zW2ldICE9PSAnc3RyaW5nJyB8fCB0aGlzLl9zdHJlYW1zW2ldLnN1YnN0cmluZyggMiwgYm91bmRhcnkubGVuZ3RoICsgMiApICE9PSBib3VuZGFyeSkge1xuICAgICAgICBkYXRhQnVmZmVyID0gQnVmZmVyLmNvbmNhdCggW2RhdGFCdWZmZXIsIEJ1ZmZlci5mcm9tKEZvcm1EYXRhLkxJTkVfQlJFQUspXSApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIEFkZCB0aGUgZm9vdGVyIGFuZCByZXR1cm4gdGhlIEJ1ZmZlciBvYmplY3QuXG4gIHJldHVybiBCdWZmZXIuY29uY2F0KCBbZGF0YUJ1ZmZlciwgQnVmZmVyLmZyb20odGhpcy5fbGFzdEJvdW5kYXJ5KCkpXSApO1xufTtcblxuRm9ybURhdGEucHJvdG90eXBlLl9nZW5lcmF0ZUJvdW5kYXJ5ID0gZnVuY3Rpb24oKSB7XG4gIC8vIFRoaXMgZ2VuZXJhdGVzIGEgNTAgY2hhcmFjdGVyIGJvdW5kYXJ5IHNpbWlsYXIgdG8gdGhvc2UgdXNlZCBieSBGaXJlZm94LlxuICAvLyBUaGV5IGFyZSBvcHRpbWl6ZWQgZm9yIGJveWVyLW1vb3JlIHBhcnNpbmcuXG4gIHZhciBib3VuZGFyeSA9ICctLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSc7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMjQ7IGkrKykge1xuICAgIGJvdW5kYXJ5ICs9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwKS50b1N0cmluZygxNik7XG4gIH1cblxuICB0aGlzLl9ib3VuZGFyeSA9IGJvdW5kYXJ5O1xufTtcblxuLy8gTm90ZTogZ2V0TGVuZ3RoU3luYyBET0VTTidUIGNhbGN1bGF0ZSBzdHJlYW1zIGxlbmd0aFxuLy8gQXMgd29ya2Fyb3VuZCBvbmUgY2FuIGNhbGN1bGF0ZSBmaWxlIHNpemUgbWFudWFsbHlcbi8vIGFuZCBhZGQgaXQgYXMga25vd25MZW5ndGggb3B0aW9uXG5Gb3JtRGF0YS5wcm90b3R5cGUuZ2V0TGVuZ3RoU3luYyA9IGZ1bmN0aW9uKCkge1xuICB2YXIga25vd25MZW5ndGggPSB0aGlzLl9vdmVyaGVhZExlbmd0aCArIHRoaXMuX3ZhbHVlTGVuZ3RoO1xuXG4gIC8vIERvbid0IGdldCBjb25mdXNlZCwgdGhlcmUgYXJlIDMgXCJpbnRlcm5hbFwiIHN0cmVhbXMgZm9yIGVhY2gga2V5dmFsIHBhaXJcbiAgLy8gc28gaXQgYmFzaWNhbGx5IGNoZWNrcyBpZiB0aGVyZSBpcyBhbnkgdmFsdWUgYWRkZWQgdG8gdGhlIGZvcm1cbiAgaWYgKHRoaXMuX3N0cmVhbXMubGVuZ3RoKSB7XG4gICAga25vd25MZW5ndGggKz0gdGhpcy5fbGFzdEJvdW5kYXJ5KCkubGVuZ3RoO1xuICB9XG5cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zvcm0tZGF0YS9mb3JtLWRhdGEvaXNzdWVzLzQwXG4gIGlmICghdGhpcy5oYXNLbm93bkxlbmd0aCgpKSB7XG4gICAgLy8gU29tZSBhc3luYyBsZW5ndGggcmV0cmlldmVycyBhcmUgcHJlc2VudFxuICAgIC8vIHRoZXJlZm9yZSBzeW5jaHJvbm91cyBsZW5ndGggY2FsY3VsYXRpb24gaXMgZmFsc2UuXG4gICAgLy8gUGxlYXNlIHVzZSBnZXRMZW5ndGgoY2FsbGJhY2spIHRvIGdldCBwcm9wZXIgbGVuZ3RoXG4gICAgdGhpcy5fZXJyb3IobmV3IEVycm9yKCdDYW5ub3QgY2FsY3VsYXRlIHByb3BlciBsZW5ndGggaW4gc3luY2hyb25vdXMgd2F5LicpKTtcbiAgfVxuXG4gIHJldHVybiBrbm93bkxlbmd0aDtcbn07XG5cbi8vIFB1YmxpYyBBUEkgdG8gY2hlY2sgaWYgbGVuZ3RoIG9mIGFkZGVkIHZhbHVlcyBpcyBrbm93blxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zvcm0tZGF0YS9mb3JtLWRhdGEvaXNzdWVzLzE5NlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zvcm0tZGF0YS9mb3JtLWRhdGEvaXNzdWVzLzI2MlxuRm9ybURhdGEucHJvdG90eXBlLmhhc0tub3duTGVuZ3RoID0gZnVuY3Rpb24oKSB7XG4gIHZhciBoYXNLbm93bkxlbmd0aCA9IHRydWU7XG5cbiAgaWYgKHRoaXMuX3ZhbHVlc1RvTWVhc3VyZS5sZW5ndGgpIHtcbiAgICBoYXNLbm93bkxlbmd0aCA9IGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGhhc0tub3duTGVuZ3RoO1xufTtcblxuRm9ybURhdGEucHJvdG90eXBlLmdldExlbmd0aCA9IGZ1bmN0aW9uKGNiKSB7XG4gIHZhciBrbm93bkxlbmd0aCA9IHRoaXMuX292ZXJoZWFkTGVuZ3RoICsgdGhpcy5fdmFsdWVMZW5ndGg7XG5cbiAgaWYgKHRoaXMuX3N0cmVhbXMubGVuZ3RoKSB7XG4gICAga25vd25MZW5ndGggKz0gdGhpcy5fbGFzdEJvdW5kYXJ5KCkubGVuZ3RoO1xuICB9XG5cbiAgaWYgKCF0aGlzLl92YWx1ZXNUb01lYXN1cmUubGVuZ3RoKSB7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhjYi5iaW5kKHRoaXMsIG51bGwsIGtub3duTGVuZ3RoKSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgYXN5bmNraXQucGFyYWxsZWwodGhpcy5fdmFsdWVzVG9NZWFzdXJlLCB0aGlzLl9sZW5ndGhSZXRyaWV2ZXIsIGZ1bmN0aW9uKGVyciwgdmFsdWVzKSB7XG4gICAgaWYgKGVycikge1xuICAgICAgY2IoZXJyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YWx1ZXMuZm9yRWFjaChmdW5jdGlvbihsZW5ndGgpIHtcbiAgICAgIGtub3duTGVuZ3RoICs9IGxlbmd0aDtcbiAgICB9KTtcblxuICAgIGNiKG51bGwsIGtub3duTGVuZ3RoKTtcbiAgfSk7XG59O1xuXG5Gb3JtRGF0YS5wcm90b3R5cGUuc3VibWl0ID0gZnVuY3Rpb24ocGFyYW1zLCBjYikge1xuICB2YXIgcmVxdWVzdFxuICAgICwgb3B0aW9uc1xuICAgICwgZGVmYXVsdHMgPSB7bWV0aG9kOiAncG9zdCd9XG4gICAgO1xuXG4gIC8vIHBhcnNlIHByb3ZpZGVkIHVybCBpZiBpdCdzIHN0cmluZ1xuICAvLyBvciB0cmVhdCBpdCBhcyBvcHRpb25zIG9iamVjdFxuICBpZiAodHlwZW9mIHBhcmFtcyA9PSAnc3RyaW5nJykge1xuXG4gICAgcGFyYW1zID0gcGFyc2VVcmwocGFyYW1zKTtcbiAgICBvcHRpb25zID0gcG9wdWxhdGUoe1xuICAgICAgcG9ydDogcGFyYW1zLnBvcnQsXG4gICAgICBwYXRoOiBwYXJhbXMucGF0aG5hbWUsXG4gICAgICBob3N0OiBwYXJhbXMuaG9zdG5hbWUsXG4gICAgICBwcm90b2NvbDogcGFyYW1zLnByb3RvY29sXG4gICAgfSwgZGVmYXVsdHMpO1xuXG4gIC8vIHVzZSBjdXN0b20gcGFyYW1zXG4gIH0gZWxzZSB7XG5cbiAgICBvcHRpb25zID0gcG9wdWxhdGUocGFyYW1zLCBkZWZhdWx0cyk7XG4gICAgLy8gaWYgbm8gcG9ydCBwcm92aWRlZCB1c2UgZGVmYXVsdCBvbmVcbiAgICBpZiAoIW9wdGlvbnMucG9ydCkge1xuICAgICAgb3B0aW9ucy5wb3J0ID0gb3B0aW9ucy5wcm90b2NvbCA9PSAnaHR0cHM6JyA/IDQ0MyA6IDgwO1xuICAgIH1cbiAgfVxuXG4gIC8vIHB1dCB0aGF0IGdvb2QgY29kZSBpbiBnZXRIZWFkZXJzIHRvIHNvbWUgdXNlXG4gIG9wdGlvbnMuaGVhZGVycyA9IHRoaXMuZ2V0SGVhZGVycyhwYXJhbXMuaGVhZGVycyk7XG5cbiAgLy8gaHR0cHMgaWYgc3BlY2lmaWVkLCBmYWxsYmFjayB0byBodHRwIGluIGFueSBvdGhlciBjYXNlXG4gIGlmIChvcHRpb25zLnByb3RvY29sID09ICdodHRwczonKSB7XG4gICAgcmVxdWVzdCA9IGh0dHBzLnJlcXVlc3Qob3B0aW9ucyk7XG4gIH0gZWxzZSB7XG4gICAgcmVxdWVzdCA9IGh0dHAucmVxdWVzdChvcHRpb25zKTtcbiAgfVxuXG4gIC8vIGdldCBjb250ZW50IGxlbmd0aCBhbmQgZmlyZSBhd2F5XG4gIHRoaXMuZ2V0TGVuZ3RoKGZ1bmN0aW9uKGVyciwgbGVuZ3RoKSB7XG4gICAgaWYgKGVyciAmJiBlcnIgIT09ICdVbmtub3duIHN0cmVhbScpIHtcbiAgICAgIHRoaXMuX2Vycm9yKGVycik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYWRkIGNvbnRlbnQgbGVuZ3RoXG4gICAgaWYgKGxlbmd0aCkge1xuICAgICAgcmVxdWVzdC5zZXRIZWFkZXIoJ0NvbnRlbnQtTGVuZ3RoJywgbGVuZ3RoKTtcbiAgICB9XG5cbiAgICB0aGlzLnBpcGUocmVxdWVzdCk7XG4gICAgaWYgKGNiKSB7XG4gICAgICB2YXIgb25SZXNwb25zZTtcblxuICAgICAgdmFyIGNhbGxiYWNrID0gZnVuY3Rpb24gKGVycm9yLCByZXNwb25jZSkge1xuICAgICAgICByZXF1ZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIGNhbGxiYWNrKTtcbiAgICAgICAgcmVxdWVzdC5yZW1vdmVMaXN0ZW5lcigncmVzcG9uc2UnLCBvblJlc3BvbnNlKTtcblxuICAgICAgICByZXR1cm4gY2IuY2FsbCh0aGlzLCBlcnJvciwgcmVzcG9uY2UpO1xuICAgICAgfTtcblxuICAgICAgb25SZXNwb25zZSA9IGNhbGxiYWNrLmJpbmQodGhpcywgbnVsbCk7XG5cbiAgICAgIHJlcXVlc3Qub24oJ2Vycm9yJywgY2FsbGJhY2spO1xuICAgICAgcmVxdWVzdC5vbigncmVzcG9uc2UnLCBvblJlc3BvbnNlKTtcbiAgICB9XG4gIH0uYmluZCh0aGlzKSk7XG5cbiAgcmV0dXJuIHJlcXVlc3Q7XG59O1xuXG5Gb3JtRGF0YS5wcm90b3R5cGUuX2Vycm9yID0gZnVuY3Rpb24oZXJyKSB7XG4gIGlmICghdGhpcy5lcnJvcikge1xuICAgIHRoaXMuZXJyb3IgPSBlcnI7XG4gICAgdGhpcy5wYXVzZSgpO1xuICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICB9XG59O1xuXG5Gb3JtRGF0YS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAnW29iamVjdCBGb3JtRGF0YV0nO1xufTtcbiJdLCJuYW1lcyI6WyJDb21iaW5lZFN0cmVhbSIsInJlcXVpcmUiLCJ1dGlsIiwicGF0aCIsImh0dHAiLCJodHRwcyIsInBhcnNlVXJsIiwicGFyc2UiLCJmcyIsIlN0cmVhbSIsIm1pbWUiLCJhc3luY2tpdCIsInBvcHVsYXRlIiwibW9kdWxlIiwiZXhwb3J0cyIsIkZvcm1EYXRhIiwiaW5oZXJpdHMiLCJvcHRpb25zIiwiX292ZXJoZWFkTGVuZ3RoIiwiX3ZhbHVlTGVuZ3RoIiwiX3ZhbHVlc1RvTWVhc3VyZSIsImNhbGwiLCJvcHRpb24iLCJMSU5FX0JSRUFLIiwiREVGQVVMVF9DT05URU5UX1RZUEUiLCJwcm90b3R5cGUiLCJhcHBlbmQiLCJmaWVsZCIsInZhbHVlIiwiZmlsZW5hbWUiLCJiaW5kIiwiaXNBcnJheSIsIl9lcnJvciIsIkVycm9yIiwiaGVhZGVyIiwiX211bHRpUGFydEhlYWRlciIsImZvb3RlciIsIl9tdWx0aVBhcnRGb290ZXIiLCJfdHJhY2tMZW5ndGgiLCJ2YWx1ZUxlbmd0aCIsImtub3duTGVuZ3RoIiwiQnVmZmVyIiwiaXNCdWZmZXIiLCJsZW5ndGgiLCJieXRlTGVuZ3RoIiwicmVhZGFibGUiLCJoYXNPd25Qcm9wZXJ0eSIsInB1c2giLCJfbGVuZ3RoUmV0cmlldmVyIiwiY2FsbGJhY2siLCJlbmQiLCJ1bmRlZmluZWQiLCJJbmZpbml0eSIsInN0YXJ0Iiwic3RhdCIsImVyciIsImZpbGVTaXplIiwic2l6ZSIsImhlYWRlcnMiLCJvbiIsInJlc3BvbnNlIiwicGF1c2UiLCJyZXN1bWUiLCJjb250ZW50RGlzcG9zaXRpb24iLCJfZ2V0Q29udGVudERpc3Bvc2l0aW9uIiwiY29udGVudFR5cGUiLCJfZ2V0Q29udGVudFR5cGUiLCJjb250ZW50cyIsImNvbmNhdCIsInByb3AiLCJBcnJheSIsImpvaW4iLCJnZXRCb3VuZGFyeSIsImZpbGVwYXRoIiwibm9ybWFsaXplIiwicmVwbGFjZSIsIm5hbWUiLCJiYXNlbmFtZSIsImNsaWVudCIsIl9odHRwTWVzc2FnZSIsImxvb2t1cCIsIm5leHQiLCJsYXN0UGFydCIsIl9zdHJlYW1zIiwiX2xhc3RCb3VuZGFyeSIsImdldEhlYWRlcnMiLCJ1c2VySGVhZGVycyIsImZvcm1IZWFkZXJzIiwidG9Mb3dlckNhc2UiLCJzZXRCb3VuZGFyeSIsImJvdW5kYXJ5IiwiX2JvdW5kYXJ5IiwiX2dlbmVyYXRlQm91bmRhcnkiLCJnZXRCdWZmZXIiLCJkYXRhQnVmZmVyIiwiYWxsb2MiLCJpIiwibGVuIiwiZnJvbSIsInN1YnN0cmluZyIsIk1hdGgiLCJmbG9vciIsInJhbmRvbSIsInRvU3RyaW5nIiwiZ2V0TGVuZ3RoU3luYyIsImhhc0tub3duTGVuZ3RoIiwiZ2V0TGVuZ3RoIiwiY2IiLCJwcm9jZXNzIiwibmV4dFRpY2siLCJwYXJhbGxlbCIsInZhbHVlcyIsImZvckVhY2giLCJzdWJtaXQiLCJwYXJhbXMiLCJyZXF1ZXN0IiwiZGVmYXVsdHMiLCJtZXRob2QiLCJwb3J0IiwicGF0aG5hbWUiLCJob3N0IiwiaG9zdG5hbWUiLCJwcm90b2NvbCIsInNldEhlYWRlciIsInBpcGUiLCJvblJlc3BvbnNlIiwiZXJyb3IiLCJyZXNwb25jZSIsInJlbW92ZUxpc3RlbmVyIiwiZW1pdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/form-data/lib/form_data.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/form-data/lib/form_data.js":
/*!*************************************************!*\
  !*** ./node_modules/form-data/lib/form_data.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var CombinedStream = __webpack_require__(/*! combined-stream */ \"(rsc)/./node_modules/combined-stream/lib/combined_stream.js\");\nvar util = __webpack_require__(/*! util */ \"util\");\nvar path = __webpack_require__(/*! path */ \"path\");\nvar http = __webpack_require__(/*! http */ \"http\");\nvar https = __webpack_require__(/*! https */ \"https\");\nvar parseUrl = (__webpack_require__(/*! url */ \"url\").parse);\nvar fs = __webpack_require__(/*! fs */ \"fs\");\nvar Stream = (__webpack_require__(/*! stream */ \"stream\").Stream);\nvar mime = __webpack_require__(/*! mime-types */ \"(rsc)/./node_modules/mime-types/index.js\");\nvar asynckit = __webpack_require__(/*! asynckit */ \"(rsc)/./node_modules/asynckit/index.js\");\nvar populate = __webpack_require__(/*! ./populate.js */ \"(rsc)/./node_modules/form-data/lib/populate.js\");\n// Public API\nmodule.exports = FormData;\n// make it a Stream\nutil.inherits(FormData, CombinedStream);\n/**\n * Create readable \"multipart/form-data\" streams.\n * Can be used to submit forms\n * and file uploads to other web applications.\n *\n * @constructor\n * @param {Object} options - Properties to be added/overriden for FormData and CombinedStream\n */ function FormData(options) {\n    if (!(this instanceof FormData)) {\n        return new FormData(options);\n    }\n    this._overheadLength = 0;\n    this._valueLength = 0;\n    this._valuesToMeasure = [];\n    CombinedStream.call(this);\n    options = options || {};\n    for(var option in options){\n        this[option] = options[option];\n    }\n}\nFormData.LINE_BREAK = \"\\r\\n\";\nFormData.DEFAULT_CONTENT_TYPE = \"application/octet-stream\";\nFormData.prototype.append = function(field, value, options) {\n    options = options || {};\n    // allow filename as single option\n    if (typeof options == \"string\") {\n        options = {\n            filename: options\n        };\n    }\n    var append = CombinedStream.prototype.append.bind(this);\n    // all that streamy business can't handle numbers\n    if (typeof value == \"number\") {\n        value = \"\" + value;\n    }\n    // https://github.com/felixge/node-form-data/issues/38\n    if (util.isArray(value)) {\n        // Please convert your array into string\n        // the way web server expects it\n        this._error(new Error(\"Arrays are not supported.\"));\n        return;\n    }\n    var header = this._multiPartHeader(field, value, options);\n    var footer = this._multiPartFooter();\n    append(header);\n    append(value);\n    append(footer);\n    // pass along options.knownLength\n    this._trackLength(header, value, options);\n};\nFormData.prototype._trackLength = function(header, value, options) {\n    var valueLength = 0;\n    // used w/ getLengthSync(), when length is known.\n    // e.g. for streaming directly from a remote server,\n    // w/ a known file a size, and not wanting to wait for\n    // incoming file to finish to get its size.\n    if (options.knownLength != null) {\n        valueLength += +options.knownLength;\n    } else if (Buffer.isBuffer(value)) {\n        valueLength = value.length;\n    } else if (typeof value === \"string\") {\n        valueLength = Buffer.byteLength(value);\n    }\n    this._valueLength += valueLength;\n    // @check why add CRLF? does this account for custom/multiple CRLFs?\n    this._overheadLength += Buffer.byteLength(header) + FormData.LINE_BREAK.length;\n    // empty or either doesn't have path or not an http response or not a stream\n    if (!value || !value.path && !(value.readable && value.hasOwnProperty(\"httpVersion\")) && !(value instanceof Stream)) {\n        return;\n    }\n    // no need to bother with the length\n    if (!options.knownLength) {\n        this._valuesToMeasure.push(value);\n    }\n};\nFormData.prototype._lengthRetriever = function(value, callback) {\n    if (value.hasOwnProperty(\"fd\")) {\n        // take read range into a account\n        // `end` = Infinity â€“> read file till the end\n        //\n        // TODO: Looks like there is bug in Node fs.createReadStream\n        // it doesn't respect `end` options without `start` options\n        // Fix it when node fixes it.\n        // https://github.com/joyent/node/issues/7819\n        if (value.end != undefined && value.end != Infinity && value.start != undefined) {\n            // when end specified\n            // no need to calculate range\n            // inclusive, starts with 0\n            callback(null, value.end + 1 - (value.start ? value.start : 0));\n        // not that fast snoopy\n        } else {\n            // still need to fetch file size from fs\n            fs.stat(value.path, function(err, stat) {\n                var fileSize;\n                if (err) {\n                    callback(err);\n                    return;\n                }\n                // update final size based on the range options\n                fileSize = stat.size - (value.start ? value.start : 0);\n                callback(null, fileSize);\n            });\n        }\n    // or http response\n    } else if (value.hasOwnProperty(\"httpVersion\")) {\n        callback(null, +value.headers[\"content-length\"]);\n    // or request stream http://github.com/mikeal/request\n    } else if (value.hasOwnProperty(\"httpModule\")) {\n        // wait till response come back\n        value.on(\"response\", function(response) {\n            value.pause();\n            callback(null, +response.headers[\"content-length\"]);\n        });\n        value.resume();\n    // something else\n    } else {\n        callback(\"Unknown stream\");\n    }\n};\nFormData.prototype._multiPartHeader = function(field, value, options) {\n    // custom header specified (as string)?\n    // it becomes responsible for boundary\n    // (e.g. to handle extra CRLFs on .NET servers)\n    if (typeof options.header == \"string\") {\n        return options.header;\n    }\n    var contentDisposition = this._getContentDisposition(value, options);\n    var contentType = this._getContentType(value, options);\n    var contents = \"\";\n    var headers = {\n        // add custom disposition as third element or keep it two elements if not\n        \"Content-Disposition\": [\n            \"form-data\",\n            'name=\"' + field + '\"'\n        ].concat(contentDisposition || []),\n        // if no content type. allow it to be empty array\n        \"Content-Type\": [].concat(contentType || [])\n    };\n    // allow custom headers.\n    if (typeof options.header == \"object\") {\n        populate(headers, options.header);\n    }\n    var header;\n    for(var prop in headers){\n        if (!headers.hasOwnProperty(prop)) continue;\n        header = headers[prop];\n        // skip nullish headers.\n        if (header == null) {\n            continue;\n        }\n        // convert all headers to arrays.\n        if (!Array.isArray(header)) {\n            header = [\n                header\n            ];\n        }\n        // add non-empty headers.\n        if (header.length) {\n            contents += prop + \": \" + header.join(\"; \") + FormData.LINE_BREAK;\n        }\n    }\n    return \"--\" + this.getBoundary() + FormData.LINE_BREAK + contents + FormData.LINE_BREAK;\n};\nFormData.prototype._getContentDisposition = function(value, options) {\n    var filename, contentDisposition;\n    if (typeof options.filepath === \"string\") {\n        // custom filepath for relative paths\n        filename = path.normalize(options.filepath).replace(/\\\\/g, \"/\");\n    } else if (options.filename || value.name || value.path) {\n        // custom filename take precedence\n        // formidable and the browser add a name property\n        // fs- and request- streams have path property\n        filename = path.basename(options.filename || value.name || value.path);\n    } else if (value.readable && value.hasOwnProperty(\"httpVersion\")) {\n        // or try http response\n        filename = path.basename(value.client._httpMessage.path || \"\");\n    }\n    if (filename) {\n        contentDisposition = 'filename=\"' + filename + '\"';\n    }\n    return contentDisposition;\n};\nFormData.prototype._getContentType = function(value, options) {\n    // use custom content-type above all\n    var contentType = options.contentType;\n    // or try `name` from formidable, browser\n    if (!contentType && value.name) {\n        contentType = mime.lookup(value.name);\n    }\n    // or try `path` from fs-, request- streams\n    if (!contentType && value.path) {\n        contentType = mime.lookup(value.path);\n    }\n    // or if it's http-reponse\n    if (!contentType && value.readable && value.hasOwnProperty(\"httpVersion\")) {\n        contentType = value.headers[\"content-type\"];\n    }\n    // or guess it from the filepath or filename\n    if (!contentType && (options.filepath || options.filename)) {\n        contentType = mime.lookup(options.filepath || options.filename);\n    }\n    // fallback to the default content type if `value` is not simple value\n    if (!contentType && typeof value == \"object\") {\n        contentType = FormData.DEFAULT_CONTENT_TYPE;\n    }\n    return contentType;\n};\nFormData.prototype._multiPartFooter = function() {\n    return (function(next) {\n        var footer = FormData.LINE_BREAK;\n        var lastPart = this._streams.length === 0;\n        if (lastPart) {\n            footer += this._lastBoundary();\n        }\n        next(footer);\n    }).bind(this);\n};\nFormData.prototype._lastBoundary = function() {\n    return \"--\" + this.getBoundary() + \"--\" + FormData.LINE_BREAK;\n};\nFormData.prototype.getHeaders = function(userHeaders) {\n    var header;\n    var formHeaders = {\n        \"content-type\": \"multipart/form-data; boundary=\" + this.getBoundary()\n    };\n    for(header in userHeaders){\n        if (userHeaders.hasOwnProperty(header)) {\n            formHeaders[header.toLowerCase()] = userHeaders[header];\n        }\n    }\n    return formHeaders;\n};\nFormData.prototype.setBoundary = function(boundary) {\n    this._boundary = boundary;\n};\nFormData.prototype.getBoundary = function() {\n    if (!this._boundary) {\n        this._generateBoundary();\n    }\n    return this._boundary;\n};\nFormData.prototype.getBuffer = function() {\n    var dataBuffer = new Buffer.alloc(0);\n    var boundary = this.getBoundary();\n    // Create the form content. Add Line breaks to the end of data.\n    for(var i = 0, len = this._streams.length; i < len; i++){\n        if (typeof this._streams[i] !== \"function\") {\n            // Add content to the buffer.\n            if (Buffer.isBuffer(this._streams[i])) {\n                dataBuffer = Buffer.concat([\n                    dataBuffer,\n                    this._streams[i]\n                ]);\n            } else {\n                dataBuffer = Buffer.concat([\n                    dataBuffer,\n                    Buffer.from(this._streams[i])\n                ]);\n            }\n            // Add break after content.\n            if (typeof this._streams[i] !== \"string\" || this._streams[i].substring(2, boundary.length + 2) !== boundary) {\n                dataBuffer = Buffer.concat([\n                    dataBuffer,\n                    Buffer.from(FormData.LINE_BREAK)\n                ]);\n            }\n        }\n    }\n    // Add the footer and return the Buffer object.\n    return Buffer.concat([\n        dataBuffer,\n        Buffer.from(this._lastBoundary())\n    ]);\n};\nFormData.prototype._generateBoundary = function() {\n    // This generates a 50 character boundary similar to those used by Firefox.\n    // They are optimized for boyer-moore parsing.\n    var boundary = \"--------------------------\";\n    for(var i = 0; i < 24; i++){\n        boundary += Math.floor(Math.random() * 10).toString(16);\n    }\n    this._boundary = boundary;\n};\n// Note: getLengthSync DOESN'T calculate streams length\n// As workaround one can calculate file size manually\n// and add it as knownLength option\nFormData.prototype.getLengthSync = function() {\n    var knownLength = this._overheadLength + this._valueLength;\n    // Don't get confused, there are 3 \"internal\" streams for each keyval pair\n    // so it basically checks if there is any value added to the form\n    if (this._streams.length) {\n        knownLength += this._lastBoundary().length;\n    }\n    // https://github.com/form-data/form-data/issues/40\n    if (!this.hasKnownLength()) {\n        // Some async length retrievers are present\n        // therefore synchronous length calculation is false.\n        // Please use getLength(callback) to get proper length\n        this._error(new Error(\"Cannot calculate proper length in synchronous way.\"));\n    }\n    return knownLength;\n};\n// Public API to check if length of added values is known\n// https://github.com/form-data/form-data/issues/196\n// https://github.com/form-data/form-data/issues/262\nFormData.prototype.hasKnownLength = function() {\n    var hasKnownLength = true;\n    if (this._valuesToMeasure.length) {\n        hasKnownLength = false;\n    }\n    return hasKnownLength;\n};\nFormData.prototype.getLength = function(cb) {\n    var knownLength = this._overheadLength + this._valueLength;\n    if (this._streams.length) {\n        knownLength += this._lastBoundary().length;\n    }\n    if (!this._valuesToMeasure.length) {\n        process.nextTick(cb.bind(this, null, knownLength));\n        return;\n    }\n    asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, function(err, values) {\n        if (err) {\n            cb(err);\n            return;\n        }\n        values.forEach(function(length) {\n            knownLength += length;\n        });\n        cb(null, knownLength);\n    });\n};\nFormData.prototype.submit = function(params, cb) {\n    var request, options, defaults = {\n        method: \"post\"\n    };\n    // parse provided url if it's string\n    // or treat it as options object\n    if (typeof params == \"string\") {\n        params = parseUrl(params);\n        options = populate({\n            port: params.port,\n            path: params.pathname,\n            host: params.hostname,\n            protocol: params.protocol\n        }, defaults);\n    // use custom params\n    } else {\n        options = populate(params, defaults);\n        // if no port provided use default one\n        if (!options.port) {\n            options.port = options.protocol == \"https:\" ? 443 : 80;\n        }\n    }\n    // put that good code in getHeaders to some use\n    options.headers = this.getHeaders(params.headers);\n    // https if specified, fallback to http in any other case\n    if (options.protocol == \"https:\") {\n        request = https.request(options);\n    } else {\n        request = http.request(options);\n    }\n    // get content length and fire away\n    this.getLength((function(err, length) {\n        if (err && err !== \"Unknown stream\") {\n            this._error(err);\n            return;\n        }\n        // add content length\n        if (length) {\n            request.setHeader(\"Content-Length\", length);\n        }\n        this.pipe(request);\n        if (cb) {\n            var onResponse;\n            var callback = function(error, responce) {\n                request.removeListener(\"error\", callback);\n                request.removeListener(\"response\", onResponse);\n                return cb.call(this, error, responce);\n            };\n            onResponse = callback.bind(this, null);\n            request.on(\"error\", callback);\n            request.on(\"response\", onResponse);\n        }\n    }).bind(this));\n    return request;\n};\nFormData.prototype._error = function(err) {\n    if (!this.error) {\n        this.error = err;\n        this.pause();\n        this.emit(\"error\", err);\n    }\n};\nFormData.prototype.toString = function() {\n    return \"[object FormData]\";\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZm9ybS1kYXRhL2xpYi9mb3JtX2RhdGEuanMiLCJtYXBwaW5ncyI6IkFBQUEsSUFBSUEsaUJBQWlCQyxtQkFBT0EsQ0FBQztBQUM3QixJQUFJQyxPQUFPRCxtQkFBT0EsQ0FBQztBQUNuQixJQUFJRSxPQUFPRixtQkFBT0EsQ0FBQztBQUNuQixJQUFJRyxPQUFPSCxtQkFBT0EsQ0FBQztBQUNuQixJQUFJSSxRQUFRSixtQkFBT0EsQ0FBQztBQUNwQixJQUFJSyxXQUFXTCw2Q0FBb0I7QUFDbkMsSUFBSU8sS0FBS1AsbUJBQU9BLENBQUM7QUFDakIsSUFBSVEsU0FBU1Isb0RBQXdCO0FBQ3JDLElBQUlTLE9BQU9ULG1CQUFPQSxDQUFDO0FBQ25CLElBQUlVLFdBQVdWLG1CQUFPQSxDQUFDO0FBQ3ZCLElBQUlXLFdBQVdYLG1CQUFPQSxDQUFDO0FBRXZCLGFBQWE7QUFDYlksT0FBT0MsT0FBTyxHQUFHQztBQUVqQixtQkFBbUI7QUFDbkJiLEtBQUtjLFFBQVEsQ0FBQ0QsVUFBVWY7QUFFeEI7Ozs7Ozs7Q0FPQyxHQUNELFNBQVNlLFNBQVNFLE9BQU87SUFDdkIsSUFBSSxDQUFFLEtBQUksWUFBWUYsUUFBTyxHQUFJO1FBQy9CLE9BQU8sSUFBSUEsU0FBU0U7SUFDdEI7SUFFQSxJQUFJLENBQUNDLGVBQWUsR0FBRztJQUN2QixJQUFJLENBQUNDLFlBQVksR0FBRztJQUNwQixJQUFJLENBQUNDLGdCQUFnQixHQUFHLEVBQUU7SUFFMUJwQixlQUFlcUIsSUFBSSxDQUFDLElBQUk7SUFFeEJKLFVBQVVBLFdBQVcsQ0FBQztJQUN0QixJQUFLLElBQUlLLFVBQVVMLFFBQVM7UUFDMUIsSUFBSSxDQUFDSyxPQUFPLEdBQUdMLE9BQU8sQ0FBQ0ssT0FBTztJQUNoQztBQUNGO0FBRUFQLFNBQVNRLFVBQVUsR0FBRztBQUN0QlIsU0FBU1Msb0JBQW9CLEdBQUc7QUFFaENULFNBQVNVLFNBQVMsQ0FBQ0MsTUFBTSxHQUFHLFNBQVNDLEtBQUss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VSxTQUFTLENBQUM4RSxRQUFRLEdBQUc7SUFDNUIsT0FBTztBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdmhkLXR2Ly4vbm9kZV9tb2R1bGVzL2Zvcm0tZGF0YS9saWIvZm9ybV9kYXRhLmpzPzJiMGQiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIENvbWJpbmVkU3RyZWFtID0gcmVxdWlyZSgnY29tYmluZWQtc3RyZWFtJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbnZhciBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xudmFyIGh0dHAgPSByZXF1aXJlKCdodHRwJyk7XG52YXIgaHR0cHMgPSByZXF1aXJlKCdodHRwcycpO1xudmFyIHBhcnNlVXJsID0gcmVxdWlyZSgndXJsJykucGFyc2U7XG52YXIgZnMgPSByZXF1aXJlKCdmcycpO1xudmFyIFN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpLlN0cmVhbTtcbnZhciBtaW1lID0gcmVxdWlyZSgnbWltZS10eXBlcycpO1xudmFyIGFzeW5ja2l0ID0gcmVxdWlyZSgnYXN5bmNraXQnKTtcbnZhciBwb3B1bGF0ZSA9IHJlcXVpcmUoJy4vcG9wdWxhdGUuanMnKTtcblxuLy8gUHVibGljIEFQSVxubW9kdWxlLmV4cG9ydHMgPSBGb3JtRGF0YTtcblxuLy8gbWFrZSBpdCBhIFN0cmVhbVxudXRpbC5pbmhlcml0cyhGb3JtRGF0YSwgQ29tYmluZWRTdHJlYW0pO1xuXG4vKipcbiAqIENyZWF0ZSByZWFkYWJsZSBcIm11bHRpcGFydC9mb3JtLWRhdGFcIiBzdHJlYW1zLlxuICogQ2FuIGJlIHVzZWQgdG8gc3VibWl0IGZvcm1zXG4gKiBhbmQgZmlsZSB1cGxvYWRzIHRvIG90aGVyIHdlYiBhcHBsaWNhdGlvbnMuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFByb3BlcnRpZXMgdG8gYmUgYWRkZWQvb3ZlcnJpZGVuIGZvciBGb3JtRGF0YSBhbmQgQ29tYmluZWRTdHJlYW1cbiAqL1xuZnVuY3Rpb24gRm9ybURhdGEob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRm9ybURhdGEpKSB7XG4gICAgcmV0dXJuIG5ldyBGb3JtRGF0YShvcHRpb25zKTtcbiAgfVxuXG4gIHRoaXMuX292ZXJoZWFkTGVuZ3RoID0gMDtcbiAgdGhpcy5fdmFsdWVMZW5ndGggPSAwO1xuICB0aGlzLl92YWx1ZXNUb01lYXN1cmUgPSBbXTtcblxuICBDb21iaW5lZFN0cmVhbS5jYWxsKHRoaXMpO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBmb3IgKHZhciBvcHRpb24gaW4gb3B0aW9ucykge1xuICAgIHRoaXNbb3B0aW9uXSA9IG9wdGlvbnNbb3B0aW9uXTtcbiAgfVxufVxuXG5Gb3JtRGF0YS5MSU5FX0JSRUFLID0gJ1xcclxcbic7XG5Gb3JtRGF0YS5ERUZBVUxUX0NPTlRFTlRfVFlQRSA9ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nO1xuXG5Gb3JtRGF0YS5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24oZmllbGQsIHZhbHVlLCBvcHRpb25zKSB7XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gYWxsb3cgZmlsZW5hbWUgYXMgc2luZ2xlIG9wdGlvblxuICBpZiAodHlwZW9mIG9wdGlvbnMgPT0gJ3N0cmluZycpIHtcbiAgICBvcHRpb25zID0ge2ZpbGVuYW1lOiBvcHRpb25zfTtcbiAgfVxuXG4gIHZhciBhcHBlbmQgPSBDb21iaW5lZFN0cmVhbS5wcm90b3R5cGUuYXBwZW5kLmJpbmQodGhpcyk7XG5cbiAgLy8gYWxsIHRoYXQgc3RyZWFteSBidXNpbmVzcyBjYW4ndCBoYW5kbGUgbnVtYmVyc1xuICBpZiAodHlwZW9mIHZhbHVlID09ICdudW1iZXInKSB7XG4gICAgdmFsdWUgPSAnJyArIHZhbHVlO1xuICB9XG5cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZlbGl4Z2Uvbm9kZS1mb3JtLWRhdGEvaXNzdWVzLzM4XG4gIGlmICh1dGlsLmlzQXJyYXkodmFsdWUpKSB7XG4gICAgLy8gUGxlYXNlIGNvbnZlcnQgeW91ciBhcnJheSBpbnRvIHN0cmluZ1xuICAgIC8vIHRoZSB3YXkgd2ViIHNlcnZlciBleHBlY3RzIGl0XG4gICAgdGhpcy5fZXJyb3IobmV3IEVycm9yKCdBcnJheXMgYXJlIG5vdCBzdXBwb3J0ZWQuJykpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBoZWFkZXIgPSB0aGlzLl9tdWx0aVBhcnRIZWFkZXIoZmllbGQsIHZhbHVlLCBvcHRpb25zKTtcbiAgdmFyIGZvb3RlciA9IHRoaXMuX211bHRpUGFydEZvb3RlcigpO1xuXG4gIGFwcGVuZChoZWFkZXIpO1xuICBhcHBlbmQodmFsdWUpO1xuICBhcHBlbmQoZm9vdGVyKTtcblxuICAvLyBwYXNzIGFsb25nIG9wdGlvbnMua25vd25MZW5ndGhcbiAgdGhpcy5fdHJhY2tMZW5ndGgoaGVhZGVyLCB2YWx1ZSwgb3B0aW9ucyk7XG59O1xuXG5Gb3JtRGF0YS5wcm90b3R5cGUuX3RyYWNrTGVuZ3RoID0gZnVuY3Rpb24oaGVhZGVyLCB2YWx1ZSwgb3B0aW9ucykge1xuICB2YXIgdmFsdWVMZW5ndGggPSAwO1xuXG4gIC8vIHVzZWQgdy8gZ2V0TGVuZ3RoU3luYygpLCB3aGVuIGxlbmd0aCBpcyBrbm93bi5cbiAgLy8gZS5nLiBmb3Igc3RyZWFtaW5nIGRpcmVjdGx5IGZyb20gYSByZW1vdGUgc2VydmVyLFxuICAvLyB3LyBhIGtub3duIGZpbGUgYSBzaXplLCBhbmQgbm90IHdhbnRpbmcgdG8gd2FpdCBmb3JcbiAgLy8gaW5jb21pbmcgZmlsZSB0byBmaW5pc2ggdG8gZ2V0IGl0cyBzaXplLlxuICBpZiAob3B0aW9ucy5rbm93bkxlbmd0aCAhPSBudWxsKSB7XG4gICAgdmFsdWVMZW5ndGggKz0gK29wdGlvbnMua25vd25MZW5ndGg7XG4gIH0gZWxzZSBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSkge1xuICAgIHZhbHVlTGVuZ3RoID0gdmFsdWUubGVuZ3RoO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWx1ZUxlbmd0aCA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbHVlKTtcbiAgfVxuXG4gIHRoaXMuX3ZhbHVlTGVuZ3RoICs9IHZhbHVlTGVuZ3RoO1xuXG4gIC8vIEBjaGVjayB3aHkgYWRkIENSTEY/IGRvZXMgdGhpcyBhY2NvdW50IGZvciBjdXN0b20vbXVsdGlwbGUgQ1JMRnM/XG4gIHRoaXMuX292ZXJoZWFkTGVuZ3RoICs9XG4gICAgQnVmZmVyLmJ5dGVMZW5ndGgoaGVhZGVyKSArXG4gICAgRm9ybURhdGEuTElORV9CUkVBSy5sZW5ndGg7XG5cbiAgLy8gZW1wdHkgb3IgZWl0aGVyIGRvZXNuJ3QgaGF2ZSBwYXRoIG9yIG5vdCBhbiBodHRwIHJlc3BvbnNlIG9yIG5vdCBhIHN0cmVhbVxuICBpZiAoIXZhbHVlIHx8ICggIXZhbHVlLnBhdGggJiYgISh2YWx1ZS5yZWFkYWJsZSAmJiB2YWx1ZS5oYXNPd25Qcm9wZXJ0eSgnaHR0cFZlcnNpb24nKSkgJiYgISh2YWx1ZSBpbnN0YW5jZW9mIFN0cmVhbSkpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gbm8gbmVlZCB0byBib3RoZXIgd2l0aCB0aGUgbGVuZ3RoXG4gIGlmICghb3B0aW9ucy5rbm93bkxlbmd0aCkge1xuICAgIHRoaXMuX3ZhbHVlc1RvTWVhc3VyZS5wdXNoKHZhbHVlKTtcbiAgfVxufTtcblxuRm9ybURhdGEucHJvdG90eXBlLl9sZW5ndGhSZXRyaWV2ZXIgPSBmdW5jdGlvbih2YWx1ZSwgY2FsbGJhY2spIHtcblxuICBpZiAodmFsdWUuaGFzT3duUHJvcGVydHkoJ2ZkJykpIHtcblxuICAgIC8vIHRha2UgcmVhZCByYW5nZSBpbnRvIGEgYWNjb3VudFxuICAgIC8vIGBlbmRgID0gSW5maW5pdHkg4oCTPiByZWFkIGZpbGUgdGlsbCB0aGUgZW5kXG4gICAgLy9cbiAgICAvLyBUT0RPOiBMb29rcyBsaWtlIHRoZXJlIGlzIGJ1ZyBpbiBOb2RlIGZzLmNyZWF0ZVJlYWRTdHJlYW1cbiAgICAvLyBpdCBkb2Vzbid0IHJlc3BlY3QgYGVuZGAgb3B0aW9ucyB3aXRob3V0IGBzdGFydGAgb3B0aW9uc1xuICAgIC8vIEZpeCBpdCB3aGVuIG5vZGUgZml4ZXMgaXQuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2pveWVudC9ub2RlL2lzc3Vlcy83ODE5XG4gICAgaWYgKHZhbHVlLmVuZCAhPSB1bmRlZmluZWQgJiYgdmFsdWUuZW5kICE9IEluZmluaXR5ICYmIHZhbHVlLnN0YXJ0ICE9IHVuZGVmaW5lZCkge1xuXG4gICAgICAvLyB3aGVuIGVuZCBzcGVjaWZpZWRcbiAgICAgIC8vIG5vIG5lZWQgdG8gY2FsY3VsYXRlIHJhbmdlXG4gICAgICAvLyBpbmNsdXNpdmUsIHN0YXJ0cyB3aXRoIDBcbiAgICAgIGNhbGxiYWNrKG51bGwsIHZhbHVlLmVuZCArIDEgLSAodmFsdWUuc3RhcnQgPyB2YWx1ZS5zdGFydCA6IDApKTtcblxuICAgIC8vIG5vdCB0aGF0IGZhc3Qgc25vb3B5XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHN0aWxsIG5lZWQgdG8gZmV0Y2ggZmlsZSBzaXplIGZyb20gZnNcbiAgICAgIGZzLnN0YXQodmFsdWUucGF0aCwgZnVuY3Rpb24oZXJyLCBzdGF0KSB7XG5cbiAgICAgICAgdmFyIGZpbGVTaXplO1xuXG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHVwZGF0ZSBmaW5hbCBzaXplIGJhc2VkIG9uIHRoZSByYW5nZSBvcHRpb25zXG4gICAgICAgIGZpbGVTaXplID0gc3RhdC5zaXplIC0gKHZhbHVlLnN0YXJ0ID8gdmFsdWUuc3RhcnQgOiAwKTtcbiAgICAgICAgY2FsbGJhY2sobnVsbCwgZmlsZVNpemUpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gIC8vIG9yIGh0dHAgcmVzcG9uc2VcbiAgfSBlbHNlIGlmICh2YWx1ZS5oYXNPd25Qcm9wZXJ0eSgnaHR0cFZlcnNpb24nKSkge1xuICAgIGNhbGxiYWNrKG51bGwsICt2YWx1ZS5oZWFkZXJzWydjb250ZW50LWxlbmd0aCddKTtcblxuICAvLyBvciByZXF1ZXN0IHN0cmVhbSBodHRwOi8vZ2l0aHViLmNvbS9taWtlYWwvcmVxdWVzdFxuICB9IGVsc2UgaWYgKHZhbHVlLmhhc093blByb3BlcnR5KCdodHRwTW9kdWxlJykpIHtcbiAgICAvLyB3YWl0IHRpbGwgcmVzcG9uc2UgY29tZSBiYWNrXG4gICAgdmFsdWUub24oJ3Jlc3BvbnNlJywgZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgIHZhbHVlLnBhdXNlKCk7XG4gICAgICBjYWxsYmFjayhudWxsLCArcmVzcG9uc2UuaGVhZGVyc1snY29udGVudC1sZW5ndGgnXSk7XG4gICAgfSk7XG4gICAgdmFsdWUucmVzdW1lKCk7XG5cbiAgLy8gc29tZXRoaW5nIGVsc2VcbiAgfSBlbHNlIHtcbiAgICBjYWxsYmFjaygnVW5rbm93biBzdHJlYW0nKTtcbiAgfVxufTtcblxuRm9ybURhdGEucHJvdG90eXBlLl9tdWx0aVBhcnRIZWFkZXIgPSBmdW5jdGlvbihmaWVsZCwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgLy8gY3VzdG9tIGhlYWRlciBzcGVjaWZpZWQgKGFzIHN0cmluZyk/XG4gIC8vIGl0IGJlY29tZXMgcmVzcG9uc2libGUgZm9yIGJvdW5kYXJ5XG4gIC8vIChlLmcuIHRvIGhhbmRsZSBleHRyYSBDUkxGcyBvbiAuTkVUIHNlcnZlcnMpXG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5oZWFkZXIgPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5oZWFkZXI7XG4gIH1cblxuICB2YXIgY29udGVudERpc3Bvc2l0aW9uID0gdGhpcy5fZ2V0Q29udGVudERpc3Bvc2l0aW9uKHZhbHVlLCBvcHRpb25zKTtcbiAgdmFyIGNvbnRlbnRUeXBlID0gdGhpcy5fZ2V0Q29udGVudFR5cGUodmFsdWUsIG9wdGlvbnMpO1xuXG4gIHZhciBjb250ZW50cyA9ICcnO1xuICB2YXIgaGVhZGVycyAgPSB7XG4gICAgLy8gYWRkIGN1c3RvbSBkaXNwb3NpdGlvbiBhcyB0aGlyZCBlbGVtZW50IG9yIGtlZXAgaXQgdHdvIGVsZW1lbnRzIGlmIG5vdFxuICAgICdDb250ZW50LURpc3Bvc2l0aW9uJzogWydmb3JtLWRhdGEnLCAnbmFtZT1cIicgKyBmaWVsZCArICdcIiddLmNvbmNhdChjb250ZW50RGlzcG9zaXRpb24gfHwgW10pLFxuICAgIC8vIGlmIG5vIGNvbnRlbnQgdHlwZS4gYWxsb3cgaXQgdG8gYmUgZW1wdHkgYXJyYXlcbiAgICAnQ29udGVudC1UeXBlJzogW10uY29uY2F0KGNvbnRlbnRUeXBlIHx8IFtdKVxuICB9O1xuXG4gIC8vIGFsbG93IGN1c3RvbSBoZWFkZXJzLlxuICBpZiAodHlwZW9mIG9wdGlvbnMuaGVhZGVyID09ICdvYmplY3QnKSB7XG4gICAgcG9wdWxhdGUoaGVhZGVycywgb3B0aW9ucy5oZWFkZXIpO1xuICB9XG5cbiAgdmFyIGhlYWRlcjtcbiAgZm9yICh2YXIgcHJvcCBpbiBoZWFkZXJzKSB7XG4gICAgaWYgKCFoZWFkZXJzLmhhc093blByb3BlcnR5KHByb3ApKSBjb250aW51ZTtcbiAgICBoZWFkZXIgPSBoZWFkZXJzW3Byb3BdO1xuXG4gICAgLy8gc2tpcCBudWxsaXNoIGhlYWRlcnMuXG4gICAgaWYgKGhlYWRlciA9PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBjb252ZXJ0IGFsbCBoZWFkZXJzIHRvIGFycmF5cy5cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoaGVhZGVyKSkge1xuICAgICAgaGVhZGVyID0gW2hlYWRlcl07XG4gICAgfVxuXG4gICAgLy8gYWRkIG5vbi1lbXB0eSBoZWFkZXJzLlxuICAgIGlmIChoZWFkZXIubGVuZ3RoKSB7XG4gICAgICBjb250ZW50cyArPSBwcm9wICsgJzogJyArIGhlYWRlci5qb2luKCc7ICcpICsgRm9ybURhdGEuTElORV9CUkVBSztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gJy0tJyArIHRoaXMuZ2V0Qm91bmRhcnkoKSArIEZvcm1EYXRhLkxJTkVfQlJFQUsgKyBjb250ZW50cyArIEZvcm1EYXRhLkxJTkVfQlJFQUs7XG59O1xuXG5Gb3JtRGF0YS5wcm90b3R5cGUuX2dldENvbnRlbnREaXNwb3NpdGlvbiA9IGZ1bmN0aW9uKHZhbHVlLCBvcHRpb25zKSB7XG5cbiAgdmFyIGZpbGVuYW1lXG4gICAgLCBjb250ZW50RGlzcG9zaXRpb25cbiAgICA7XG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zLmZpbGVwYXRoID09PSAnc3RyaW5nJykge1xuICAgIC8vIGN1c3RvbSBmaWxlcGF0aCBmb3IgcmVsYXRpdmUgcGF0aHNcbiAgICBmaWxlbmFtZSA9IHBhdGgubm9ybWFsaXplKG9wdGlvbnMuZmlsZXBhdGgpLnJlcGxhY2UoL1xcXFwvZywgJy8nKTtcbiAgfSBlbHNlIGlmIChvcHRpb25zLmZpbGVuYW1lIHx8IHZhbHVlLm5hbWUgfHwgdmFsdWUucGF0aCkge1xuICAgIC8vIGN1c3RvbSBmaWxlbmFtZSB0YWtlIHByZWNlZGVuY2VcbiAgICAvLyBmb3JtaWRhYmxlIGFuZCB0aGUgYnJvd3NlciBhZGQgYSBuYW1lIHByb3BlcnR5XG4gICAgLy8gZnMtIGFuZCByZXF1ZXN0LSBzdHJlYW1zIGhhdmUgcGF0aCBwcm9wZXJ0eVxuICAgIGZpbGVuYW1lID0gcGF0aC5iYXNlbmFtZShvcHRpb25zLmZpbGVuYW1lIHx8IHZhbHVlLm5hbWUgfHwgdmFsdWUucGF0aCk7XG4gIH0gZWxzZSBpZiAodmFsdWUucmVhZGFibGUgJiYgdmFsdWUuaGFzT3duUHJvcGVydHkoJ2h0dHBWZXJzaW9uJykpIHtcbiAgICAvLyBvciB0cnkgaHR0cCByZXNwb25zZVxuICAgIGZpbGVuYW1lID0gcGF0aC5iYXNlbmFtZSh2YWx1ZS5jbGllbnQuX2h0dHBNZXNzYWdlLnBhdGggfHwgJycpO1xuICB9XG5cbiAgaWYgKGZpbGVuYW1lKSB7XG4gICAgY29udGVudERpc3Bvc2l0aW9uID0gJ2ZpbGVuYW1lPVwiJyArIGZpbGVuYW1lICsgJ1wiJztcbiAgfVxuXG4gIHJldHVybiBjb250ZW50RGlzcG9zaXRpb247XG59O1xuXG5Gb3JtRGF0YS5wcm90b3R5cGUuX2dldENvbnRlbnRUeXBlID0gZnVuY3Rpb24odmFsdWUsIG9wdGlvbnMpIHtcblxuICAvLyB1c2UgY3VzdG9tIGNvbnRlbnQtdHlwZSBhYm92ZSBhbGxcbiAgdmFyIGNvbnRlbnRUeXBlID0gb3B0aW9ucy5jb250ZW50VHlwZTtcblxuICAvLyBvciB0cnkgYG5hbWVgIGZyb20gZm9ybWlkYWJsZSwgYnJvd3NlclxuICBpZiAoIWNvbnRlbnRUeXBlICYmIHZhbHVlLm5hbWUpIHtcbiAgICBjb250ZW50VHlwZSA9IG1pbWUubG9va3VwKHZhbHVlLm5hbWUpO1xuICB9XG5cbiAgLy8gb3IgdHJ5IGBwYXRoYCBmcm9tIGZzLSwgcmVxdWVzdC0gc3RyZWFtc1xuICBpZiAoIWNvbnRlbnRUeXBlICYmIHZhbHVlLnBhdGgpIHtcbiAgICBjb250ZW50VHlwZSA9IG1pbWUubG9va3VwKHZhbHVlLnBhdGgpO1xuICB9XG5cbiAgLy8gb3IgaWYgaXQncyBodHRwLXJlcG9uc2VcbiAgaWYgKCFjb250ZW50VHlwZSAmJiB2YWx1ZS5yZWFkYWJsZSAmJiB2YWx1ZS5oYXNPd25Qcm9wZXJ0eSgnaHR0cFZlcnNpb24nKSkge1xuICAgIGNvbnRlbnRUeXBlID0gdmFsdWUuaGVhZGVyc1snY29udGVudC10eXBlJ107XG4gIH1cblxuICAvLyBvciBndWVzcyBpdCBmcm9tIHRoZSBmaWxlcGF0aCBvciBmaWxlbmFtZVxuICBpZiAoIWNvbnRlbnRUeXBlICYmIChvcHRpb25zLmZpbGVwYXRoIHx8IG9wdGlvbnMuZmlsZW5hbWUpKSB7XG4gICAgY29udGVudFR5cGUgPSBtaW1lLmxvb2t1cChvcHRpb25zLmZpbGVwYXRoIHx8IG9wdGlvbnMuZmlsZW5hbWUpO1xuICB9XG5cbiAgLy8gZmFsbGJhY2sgdG8gdGhlIGRlZmF1bHQgY29udGVudCB0eXBlIGlmIGB2YWx1ZWAgaXMgbm90IHNpbXBsZSB2YWx1ZVxuICBpZiAoIWNvbnRlbnRUeXBlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jykge1xuICAgIGNvbnRlbnRUeXBlID0gRm9ybURhdGEuREVGQVVMVF9DT05URU5UX1RZUEU7XG4gIH1cblxuICByZXR1cm4gY29udGVudFR5cGU7XG59O1xuXG5Gb3JtRGF0YS5wcm90b3R5cGUuX211bHRpUGFydEZvb3RlciA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gZnVuY3Rpb24obmV4dCkge1xuICAgIHZhciBmb290ZXIgPSBGb3JtRGF0YS5MSU5FX0JSRUFLO1xuXG4gICAgdmFyIGxhc3RQYXJ0ID0gKHRoaXMuX3N0cmVhbXMubGVuZ3RoID09PSAwKTtcbiAgICBpZiAobGFzdFBhcnQpIHtcbiAgICAgIGZvb3RlciArPSB0aGlzLl9sYXN0Qm91bmRhcnkoKTtcbiAgICB9XG5cbiAgICBuZXh0KGZvb3Rlcik7XG4gIH0uYmluZCh0aGlzKTtcbn07XG5cbkZvcm1EYXRhLnByb3RvdHlwZS5fbGFzdEJvdW5kYXJ5ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAnLS0nICsgdGhpcy5nZXRCb3VuZGFyeSgpICsgJy0tJyArIEZvcm1EYXRhLkxJTkVfQlJFQUs7XG59O1xuXG5Gb3JtRGF0YS5wcm90b3R5cGUuZ2V0SGVhZGVycyA9IGZ1bmN0aW9uKHVzZXJIZWFkZXJzKSB7XG4gIHZhciBoZWFkZXI7XG4gIHZhciBmb3JtSGVhZGVycyA9IHtcbiAgICAnY29udGVudC10eXBlJzogJ211bHRpcGFydC9mb3JtLWRhdGE7IGJvdW5kYXJ5PScgKyB0aGlzLmdldEJvdW5kYXJ5KClcbiAgfTtcblxuICBmb3IgKGhlYWRlciBpbiB1c2VySGVhZGVycykge1xuICAgIGlmICh1c2VySGVhZGVycy5oYXNPd25Qcm9wZXJ0eShoZWFkZXIpKSB7XG4gICAgICBmb3JtSGVhZGVyc1toZWFkZXIudG9Mb3dlckNhc2UoKV0gPSB1c2VySGVhZGVyc1toZWFkZXJdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmb3JtSGVhZGVycztcbn07XG5cbkZvcm1EYXRhLnByb3RvdHlwZS5zZXRCb3VuZGFyeSA9IGZ1bmN0aW9uKGJvdW5kYXJ5KSB7XG4gIHRoaXMuX2JvdW5kYXJ5ID0gYm91bmRhcnk7XG59O1xuXG5Gb3JtRGF0YS5wcm90b3R5cGUuZ2V0Qm91bmRhcnkgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLl9ib3VuZGFyeSkge1xuICAgIHRoaXMuX2dlbmVyYXRlQm91bmRhcnkoKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLl9ib3VuZGFyeTtcbn07XG5cbkZvcm1EYXRhLnByb3RvdHlwZS5nZXRCdWZmZXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGRhdGFCdWZmZXIgPSBuZXcgQnVmZmVyLmFsbG9jKCAwICk7XG4gIHZhciBib3VuZGFyeSA9IHRoaXMuZ2V0Qm91bmRhcnkoKTtcblxuICAvLyBDcmVhdGUgdGhlIGZvcm0gY29udGVudC4gQWRkIExpbmUgYnJlYWtzIHRvIHRoZSBlbmQgb2YgZGF0YS5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX3N0cmVhbXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAodHlwZW9mIHRoaXMuX3N0cmVhbXNbaV0gIT09ICdmdW5jdGlvbicpIHtcblxuICAgICAgLy8gQWRkIGNvbnRlbnQgdG8gdGhlIGJ1ZmZlci5cbiAgICAgIGlmKEJ1ZmZlci5pc0J1ZmZlcih0aGlzLl9zdHJlYW1zW2ldKSkge1xuICAgICAgICBkYXRhQnVmZmVyID0gQnVmZmVyLmNvbmNhdCggW2RhdGFCdWZmZXIsIHRoaXMuX3N0cmVhbXNbaV1dKTtcbiAgICAgIH1lbHNlIHtcbiAgICAgICAgZGF0YUJ1ZmZlciA9IEJ1ZmZlci5jb25jYXQoIFtkYXRhQnVmZmVyLCBCdWZmZXIuZnJvbSh0aGlzLl9zdHJlYW1zW2ldKV0pO1xuICAgICAgfVxuXG4gICAgICAvLyBBZGQgYnJlYWsgYWZ0ZXIgY29udGVudC5cbiAgICAgIGlmICh0eXBlb2YgdGhpcy5fc3RyZWFtc1tpXSAhPT0gJ3N0cmluZycgfHwgdGhpcy5fc3RyZWFtc1tpXS5zdWJzdHJpbmcoIDIsIGJvdW5kYXJ5Lmxlbmd0aCArIDIgKSAhPT0gYm91bmRhcnkpIHtcbiAgICAgICAgZGF0YUJ1ZmZlciA9IEJ1ZmZlci5jb25jYXQoIFtkYXRhQnVmZmVyLCBCdWZmZXIuZnJvbShGb3JtRGF0YS5MSU5FX0JSRUFLKV0gKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBBZGQgdGhlIGZvb3RlciBhbmQgcmV0dXJuIHRoZSBCdWZmZXIgb2JqZWN0LlxuICByZXR1cm4gQnVmZmVyLmNvbmNhdCggW2RhdGFCdWZmZXIsIEJ1ZmZlci5mcm9tKHRoaXMuX2xhc3RCb3VuZGFyeSgpKV0gKTtcbn07XG5cbkZvcm1EYXRhLnByb3RvdHlwZS5fZ2VuZXJhdGVCb3VuZGFyeSA9IGZ1bmN0aW9uKCkge1xuICAvLyBUaGlzIGdlbmVyYXRlcyBhIDUwIGNoYXJhY3RlciBib3VuZGFyeSBzaW1pbGFyIHRvIHRob3NlIHVzZWQgYnkgRmlyZWZveC5cbiAgLy8gVGhleSBhcmUgb3B0aW1pemVkIGZvciBib3llci1tb29yZSBwYXJzaW5nLlxuICB2YXIgYm91bmRhcnkgPSAnLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0nO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IDI0OyBpKyspIHtcbiAgICBib3VuZGFyeSArPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMCkudG9TdHJpbmcoMTYpO1xuICB9XG5cbiAgdGhpcy5fYm91bmRhcnkgPSBib3VuZGFyeTtcbn07XG5cbi8vIE5vdGU6IGdldExlbmd0aFN5bmMgRE9FU04nVCBjYWxjdWxhdGUgc3RyZWFtcyBsZW5ndGhcbi8vIEFzIHdvcmthcm91bmQgb25lIGNhbiBjYWxjdWxhdGUgZmlsZSBzaXplIG1hbnVhbGx5XG4vLyBhbmQgYWRkIGl0IGFzIGtub3duTGVuZ3RoIG9wdGlvblxuRm9ybURhdGEucHJvdG90eXBlLmdldExlbmd0aFN5bmMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGtub3duTGVuZ3RoID0gdGhpcy5fb3ZlcmhlYWRMZW5ndGggKyB0aGlzLl92YWx1ZUxlbmd0aDtcblxuICAvLyBEb24ndCBnZXQgY29uZnVzZWQsIHRoZXJlIGFyZSAzIFwiaW50ZXJuYWxcIiBzdHJlYW1zIGZvciBlYWNoIGtleXZhbCBwYWlyXG4gIC8vIHNvIGl0IGJhc2ljYWxseSBjaGVja3MgaWYgdGhlcmUgaXMgYW55IHZhbHVlIGFkZGVkIHRvIHRoZSBmb3JtXG4gIGlmICh0aGlzLl9zdHJlYW1zLmxlbmd0aCkge1xuICAgIGtub3duTGVuZ3RoICs9IHRoaXMuX2xhc3RCb3VuZGFyeSgpLmxlbmd0aDtcbiAgfVxuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mb3JtLWRhdGEvZm9ybS1kYXRhL2lzc3Vlcy80MFxuICBpZiAoIXRoaXMuaGFzS25vd25MZW5ndGgoKSkge1xuICAgIC8vIFNvbWUgYXN5bmMgbGVuZ3RoIHJldHJpZXZlcnMgYXJlIHByZXNlbnRcbiAgICAvLyB0aGVyZWZvcmUgc3luY2hyb25vdXMgbGVuZ3RoIGNhbGN1bGF0aW9uIGlzIGZhbHNlLlxuICAgIC8vIFBsZWFzZSB1c2UgZ2V0TGVuZ3RoKGNhbGxiYWNrKSB0byBnZXQgcHJvcGVyIGxlbmd0aFxuICAgIHRoaXMuX2Vycm9yKG5ldyBFcnJvcignQ2Fubm90IGNhbGN1bGF0ZSBwcm9wZXIgbGVuZ3RoIGluIHN5bmNocm9ub3VzIHdheS4nKSk7XG4gIH1cblxuICByZXR1cm4ga25vd25MZW5ndGg7XG59O1xuXG4vLyBQdWJsaWMgQVBJIHRvIGNoZWNrIGlmIGxlbmd0aCBvZiBhZGRlZCB2YWx1ZXMgaXMga25vd25cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mb3JtLWRhdGEvZm9ybS1kYXRhL2lzc3Vlcy8xOTZcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mb3JtLWRhdGEvZm9ybS1kYXRhL2lzc3Vlcy8yNjJcbkZvcm1EYXRhLnByb3RvdHlwZS5oYXNLbm93bkxlbmd0aCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaGFzS25vd25MZW5ndGggPSB0cnVlO1xuXG4gIGlmICh0aGlzLl92YWx1ZXNUb01lYXN1cmUubGVuZ3RoKSB7XG4gICAgaGFzS25vd25MZW5ndGggPSBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBoYXNLbm93bkxlbmd0aDtcbn07XG5cbkZvcm1EYXRhLnByb3RvdHlwZS5nZXRMZW5ndGggPSBmdW5jdGlvbihjYikge1xuICB2YXIga25vd25MZW5ndGggPSB0aGlzLl9vdmVyaGVhZExlbmd0aCArIHRoaXMuX3ZhbHVlTGVuZ3RoO1xuXG4gIGlmICh0aGlzLl9zdHJlYW1zLmxlbmd0aCkge1xuICAgIGtub3duTGVuZ3RoICs9IHRoaXMuX2xhc3RCb3VuZGFyeSgpLmxlbmd0aDtcbiAgfVxuXG4gIGlmICghdGhpcy5fdmFsdWVzVG9NZWFzdXJlLmxlbmd0aCkge1xuICAgIHByb2Nlc3MubmV4dFRpY2soY2IuYmluZCh0aGlzLCBudWxsLCBrbm93bkxlbmd0aCkpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGFzeW5ja2l0LnBhcmFsbGVsKHRoaXMuX3ZhbHVlc1RvTWVhc3VyZSwgdGhpcy5fbGVuZ3RoUmV0cmlldmVyLCBmdW5jdGlvbihlcnIsIHZhbHVlcykge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIGNiKGVycik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFsdWVzLmZvckVhY2goZnVuY3Rpb24obGVuZ3RoKSB7XG4gICAgICBrbm93bkxlbmd0aCArPSBsZW5ndGg7XG4gICAgfSk7XG5cbiAgICBjYihudWxsLCBrbm93bkxlbmd0aCk7XG4gIH0pO1xufTtcblxuRm9ybURhdGEucHJvdG90eXBlLnN1Ym1pdCA9IGZ1bmN0aW9uKHBhcmFtcywgY2IpIHtcbiAgdmFyIHJlcXVlc3RcbiAgICAsIG9wdGlvbnNcbiAgICAsIGRlZmF1bHRzID0ge21ldGhvZDogJ3Bvc3QnfVxuICAgIDtcblxuICAvLyBwYXJzZSBwcm92aWRlZCB1cmwgaWYgaXQncyBzdHJpbmdcbiAgLy8gb3IgdHJlYXQgaXQgYXMgb3B0aW9ucyBvYmplY3RcbiAgaWYgKHR5cGVvZiBwYXJhbXMgPT0gJ3N0cmluZycpIHtcblxuICAgIHBhcmFtcyA9IHBhcnNlVXJsKHBhcmFtcyk7XG4gICAgb3B0aW9ucyA9IHBvcHVsYXRlKHtcbiAgICAgIHBvcnQ6IHBhcmFtcy5wb3J0LFxuICAgICAgcGF0aDogcGFyYW1zLnBhdGhuYW1lLFxuICAgICAgaG9zdDogcGFyYW1zLmhvc3RuYW1lLFxuICAgICAgcHJvdG9jb2w6IHBhcmFtcy5wcm90b2NvbFxuICAgIH0sIGRlZmF1bHRzKTtcblxuICAvLyB1c2UgY3VzdG9tIHBhcmFtc1xuICB9IGVsc2Uge1xuXG4gICAgb3B0aW9ucyA9IHBvcHVsYXRlKHBhcmFtcywgZGVmYXVsdHMpO1xuICAgIC8vIGlmIG5vIHBvcnQgcHJvdmlkZWQgdXNlIGRlZmF1bHQgb25lXG4gICAgaWYgKCFvcHRpb25zLnBvcnQpIHtcbiAgICAgIG9wdGlvbnMucG9ydCA9IG9wdGlvbnMucHJvdG9jb2wgPT0gJ2h0dHBzOicgPyA0NDMgOiA4MDtcbiAgICB9XG4gIH1cblxuICAvLyBwdXQgdGhhdCBnb29kIGNvZGUgaW4gZ2V0SGVhZGVycyB0byBzb21lIHVzZVxuICBvcHRpb25zLmhlYWRlcnMgPSB0aGlzLmdldEhlYWRlcnMocGFyYW1zLmhlYWRlcnMpO1xuXG4gIC8vIGh0dHBzIGlmIHNwZWNpZmllZCwgZmFsbGJhY2sgdG8gaHR0cCBpbiBhbnkgb3RoZXIgY2FzZVxuICBpZiAob3B0aW9ucy5wcm90b2NvbCA9PSAnaHR0cHM6Jykge1xuICAgIHJlcXVlc3QgPSBodHRwcy5yZXF1ZXN0KG9wdGlvbnMpO1xuICB9IGVsc2Uge1xuICAgIHJlcXVlc3QgPSBodHRwLnJlcXVlc3Qob3B0aW9ucyk7XG4gIH1cblxuICAvLyBnZXQgY29udGVudCBsZW5ndGggYW5kIGZpcmUgYXdheVxuICB0aGlzLmdldExlbmd0aChmdW5jdGlvbihlcnIsIGxlbmd0aCkge1xuICAgIGlmIChlcnIgJiYgZXJyICE9PSAnVW5rbm93biBzdHJlYW0nKSB7XG4gICAgICB0aGlzLl9lcnJvcihlcnIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGFkZCBjb250ZW50IGxlbmd0aFxuICAgIGlmIChsZW5ndGgpIHtcbiAgICAgIHJlcXVlc3Quc2V0SGVhZGVyKCdDb250ZW50LUxlbmd0aCcsIGxlbmd0aCk7XG4gICAgfVxuXG4gICAgdGhpcy5waXBlKHJlcXVlc3QpO1xuICAgIGlmIChjYikge1xuICAgICAgdmFyIG9uUmVzcG9uc2U7XG5cbiAgICAgIHZhciBjYWxsYmFjayA9IGZ1bmN0aW9uIChlcnJvciwgcmVzcG9uY2UpIHtcbiAgICAgICAgcmVxdWVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBjYWxsYmFjayk7XG4gICAgICAgIHJlcXVlc3QucmVtb3ZlTGlzdGVuZXIoJ3Jlc3BvbnNlJywgb25SZXNwb25zZSk7XG5cbiAgICAgICAgcmV0dXJuIGNiLmNhbGwodGhpcywgZXJyb3IsIHJlc3BvbmNlKTtcbiAgICAgIH07XG5cbiAgICAgIG9uUmVzcG9uc2UgPSBjYWxsYmFjay5iaW5kKHRoaXMsIG51bGwpO1xuXG4gICAgICByZXF1ZXN0Lm9uKCdlcnJvcicsIGNhbGxiYWNrKTtcbiAgICAgIHJlcXVlc3Qub24oJ3Jlc3BvbnNlJywgb25SZXNwb25zZSk7XG4gICAgfVxuICB9LmJpbmQodGhpcykpO1xuXG4gIHJldHVybiByZXF1ZXN0O1xufTtcblxuRm9ybURhdGEucHJvdG90eXBlLl9lcnJvciA9IGZ1bmN0aW9uKGVycikge1xuICBpZiAoIXRoaXMuZXJyb3IpIHtcbiAgICB0aGlzLmVycm9yID0gZXJyO1xuICAgIHRoaXMucGF1c2UoKTtcbiAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgfVxufTtcblxuRm9ybURhdGEucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gJ1tvYmplY3QgRm9ybURhdGFdJztcbn07XG4iXSwibmFtZXMiOlsiQ29tYmluZWRTdHJlYW0iLCJyZXF1aXJlIiwidXRpbCIsInBhdGgiLCJodHRwIiwiaHR0cHMiLCJwYXJzZVVybCIsInBhcnNlIiwiZnMiLCJTdHJlYW0iLCJtaW1lIiwiYXN5bmNraXQiLCJwb3B1bGF0ZSIsIm1vZHVsZSIsImV4cG9ydHMiLCJGb3JtRGF0YSIsImluaGVyaXRzIiwib3B0aW9ucyIsIl9vdmVyaGVhZExlbmd0aCIsIl92YWx1ZUxlbmd0aCIsIl92YWx1ZXNUb01lYXN1cmUiLCJjYWxsIiwib3B0aW9uIiwiTElORV9CUkVBSyIsIkRFRkFVTFRfQ09OVEVOVF9UWVBFIiwicHJvdG90eXBlIiwiYXBwZW5kIiwiZmllbGQiLCJ2YWx1ZSIsImZpbGVuYW1lIiwiYmluZCIsImlzQXJyYXkiLCJfZXJyb3IiLCJFcnJvciIsImhlYWRlciIsIl9tdWx0aVBhcnRIZWFkZXIiLCJmb290ZXIiLCJfbXVsdGlQYXJ0Rm9vdGVyIiwiX3RyYWNrTGVuZ3RoIiwidmFsdWVMZW5ndGgiLCJrbm93bkxlbmd0aCIsIkJ1ZmZlciIsImlzQnVmZmVyIiwibGVuZ3RoIiwiYnl0ZUxlbmd0aCIsInJlYWRhYmxlIiwiaGFzT3duUHJvcGVydHkiLCJwdXNoIiwiX2xlbmd0aFJldHJpZXZlciIsImNhbGxiYWNrIiwiZW5kIiwidW5kZWZpbmVkIiwiSW5maW5pdHkiLCJzdGFydCIsInN0YXQiLCJlcnIiLCJmaWxlU2l6ZSIsInNpemUiLCJoZWFkZXJzIiwib24iLCJyZXNwb25zZSIsInBhdXNlIiwicmVzdW1lIiwiY29udGVudERpc3Bvc2l0aW9uIiwiX2dldENvbnRlbnREaXNwb3NpdGlvbiIsImNvbnRlbnRUeXBlIiwiX2dldENvbnRlbnRUeXBlIiwiY29udGVudHMiLCJjb25jYXQiLCJwcm9wIiwiQXJyYXkiLCJqb2luIiwiZ2V0Qm91bmRhcnkiLCJmaWxlcGF0aCIsIm5vcm1hbGl6ZSIsInJlcGxhY2UiLCJuYW1lIiwiYmFzZW5hbWUiLCJjbGllbnQiLCJfaHR0cE1lc3NhZ2UiLCJsb29rdXAiLCJuZXh0IiwibGFzdFBhcnQiLCJfc3RyZWFtcyIsIl9sYXN0Qm91bmRhcnkiLCJnZXRIZWFkZXJzIiwidXNlckhlYWRlcnMiLCJmb3JtSGVhZGVycyIsInRvTG93ZXJDYXNlIiwic2V0Qm91bmRhcnkiLCJib3VuZGFyeSIsIl9ib3VuZGFyeSIsIl9nZW5lcmF0ZUJvdW5kYXJ5IiwiZ2V0QnVmZmVyIiwiZGF0YUJ1ZmZlciIsImFsbG9jIiwiaSIsImxlbiIsImZyb20iLCJzdWJzdHJpbmciLCJNYXRoIiwiZmxvb3IiLCJyYW5kb20iLCJ0b1N0cmluZyIsImdldExlbmd0aFN5bmMiLCJoYXNLbm93bkxlbmd0aCIsImdldExlbmd0aCIsImNiIiwicHJvY2VzcyIsIm5leHRUaWNrIiwicGFyYWxsZWwiLCJ2YWx1ZXMiLCJmb3JFYWNoIiwic3VibWl0IiwicGFyYW1zIiwicmVxdWVzdCIsImRlZmF1bHRzIiwibWV0aG9kIiwicG9ydCIsInBhdGhuYW1lIiwiaG9zdCIsImhvc3RuYW1lIiwicHJvdG9jb2wiLCJzZXRIZWFkZXIiLCJwaXBlIiwib25SZXNwb25zZSIsImVycm9yIiwicmVzcG9uY2UiLCJyZW1vdmVMaXN0ZW5lciIsImVtaXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/form-data/lib/form_data.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/form-data/lib/populate.js":
/*!************************************************!*\
  !*** ./node_modules/form-data/lib/populate.js ***!
  \************************************************/
/***/ ((module) => {

eval("// populates missing values\nmodule.exports = function(dst, src) {\n    Object.keys(src).forEach(function(prop) {\n        dst[prop] = dst[prop] || src[prop];\n    });\n    return dst;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92aGQtdHYvLi9ub2RlX21vZHVsZXMvZm9ybS1kYXRhL2xpYi9wb3B1bGF0ZS5qcz82NmMyIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHBvcHVsYXRlcyBtaXNzaW5nIHZhbHVlc1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihkc3QsIHNyYykge1xuXG4gIE9iamVjdC5rZXlzKHNyYykuZm9yRWFjaChmdW5jdGlvbihwcm9wKVxuICB7XG4gICAgZHN0W3Byb3BdID0gZHN0W3Byb3BdIHx8IHNyY1twcm9wXTtcbiAgfSk7XG5cbiAgcmV0dXJuIGRzdDtcbn07XG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsImRzdCIsInNyYyIsIk9iamVjdCIsImtleXMiLCJmb3JFYWNoIiwicHJvcCJdLCJtYXBwaW5ncyI6IkFBQUEsMkJBQTJCO0FBQzNCQSxPQUFPQyxPQUFPLEdBQUcsU0FBU0MsR0FBRyxFQUFFQyxHQUFHO0lBRWhDQyxPQUFPQyxJQUFJLENBQUNGLEtBQUtHLE9BQU8sQ0FBQyxTQUFTQyxJQUFJO1FBRXBDTCxHQUFHLENBQUNLLEtBQUssR0FBR0wsR0FBRyxDQUFDSyxLQUFLLElBQUlKLEdBQUcsQ0FBQ0ksS0FBSztJQUNwQztJQUVBLE9BQU9MO0FBQ1QiLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9mb3JtLWRhdGEvbGliL3BvcHVsYXRlLmpzIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/form-data/lib/populate.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/form-data/lib/populate.js":
/*!************************************************!*\
  !*** ./node_modules/form-data/lib/populate.js ***!
  \************************************************/
/***/ ((module) => {

eval("// populates missing values\nmodule.exports = function(dst, src) {\n    Object.keys(src).forEach(function(prop) {\n        dst[prop] = dst[prop] || src[prop];\n    });\n    return dst;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92aGQtdHYvLi9ub2RlX21vZHVsZXMvZm9ybS1kYXRhL2xpYi9wb3B1bGF0ZS5qcz82NmMyIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHBvcHVsYXRlcyBtaXNzaW5nIHZhbHVlc1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihkc3QsIHNyYykge1xuXG4gIE9iamVjdC5rZXlzKHNyYykuZm9yRWFjaChmdW5jdGlvbihwcm9wKVxuICB7XG4gICAgZHN0W3Byb3BdID0gZHN0W3Byb3BdIHx8IHNyY1twcm9wXTtcbiAgfSk7XG5cbiAgcmV0dXJuIGRzdDtcbn07XG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsImRzdCIsInNyYyIsIk9iamVjdCIsImtleXMiLCJmb3JFYWNoIiwicHJvcCJdLCJtYXBwaW5ncyI6IkFBQUEsMkJBQTJCO0FBQzNCQSxPQUFPQyxPQUFPLEdBQUcsU0FBU0MsR0FBRyxFQUFFQyxHQUFHO0lBRWhDQyxPQUFPQyxJQUFJLENBQUNGLEtBQUtHLE9BQU8sQ0FBQyxTQUFTQyxJQUFJO1FBRXBDTCxHQUFHLENBQUNLLEtBQUssR0FBR0wsR0FBRyxDQUFDSyxLQUFLLElBQUlKLEdBQUcsQ0FBQ0ksS0FBSztJQUNwQztJQUVBLE9BQU9MO0FBQ1QiLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZm9ybS1kYXRhL2xpYi9wb3B1bGF0ZS5qcyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/form-data/lib/populate.js\n");

/***/ })

};
;